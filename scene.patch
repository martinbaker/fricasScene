From 25f7b05a476d4cc1914dbee1d1432cd955c2f884 Mon Sep 17 00:00:00 2001
From: Martin Baker <ax87438@martinb.com>
Date: Mon, 12 Sep 2016 16:10:51 +0100
Subject: [PATCH] update scenegraph code

---
 src/algebra/scene.spad | 182 +++++++++++++++++++++++++++++++++----------------
 1 file changed, 122 insertions(+), 60 deletions(-)

diff --git a/src/algebra/scene.spad b/src/algebra/scene.spad
index 72b185a..429a748 100644
--- a/src/algebra/scene.spad
+++ b/src/algebra/scene.spad
@@ -14,7 +14,7 @@ Alternative geometry and graphics framework using scenegraph structure.
 \section{Preface}
 Its easier to explain a graphics framework with diagrams and
 screenshots so you may prefer to read the documentation here:
-\url{http : //www.euclideanspace.com/maths/standards/program/mycode/graph/}
+\url{http://www.euclideanspace.com/prog/scratchpad/mycode/graph/}
 
 This is a graphics framework to support many types of drawing,
 plotting, diagrams and various types of output that can't be
@@ -401,7 +401,7 @@ addSceneNamedPoints : (n : %, np : SceneNamedPoints PT) -> %
 \end{verbatim}
 A tutorial showing examples of how to use the named point node
 is here.
-\url{http : //www.euclideanspace.com/maths/standards/program/mycode/graph/tutorial/named/index.htm}
+\url{http://www.euclideanspace.com/prog/scratchpad/mycode/graph/tutorial/named/index.htm}
 \subsection{Shape Node}
 A shape is something like a rectangle or an ellipse in 2 dimensions
 or a sphere or box in 3 dimensions.
@@ -447,7 +447,7 @@ createSceneShape : (shape : SHAPE) -> %
 \end{verbatim}
 
 A tutorial showing examples of how to use the shape node is here.
-\url{http : //www.euclideanspace.com/maths/standards/program/mycode/graph/tutorial/shapes/index.htm}
+\url{http://www.euclideanspace.com/prog/scratchpad/mycode/graph/tutorial/shapes/}
 \subsection{Def Node}
 The 'def' and 'use' constructs are used together to allow us to include
 a branch of the scenegraph multiple times in the scene.
@@ -460,7 +460,7 @@ addSceneDef : (n : %, nam : String, nde : %) -> %
     ++ combines createSceneDef with addChild!
 \end{verbatim}
 A tutorial showing examples of how to use the def and use nodes is here.
-\url{http : //www.euclideanspace.com/maths/standards/program/mycode/graph/tutorial/defuse/index.htm}
+\url{http://www.euclideanspace.com/prog/scratchpad/mycode/graph/tutorial/defuse/}
 
 \subsection{Use Node}
 The 'def' and 'use' constructs are used together to allow us to include
@@ -473,7 +473,7 @@ addSceneUse : (n : %, nam : String) -> %
     ++ combines createSceneUse with addChild!
 \end{verbatim}
 A tutorial showing examples of how to use the def and use nodes is here.
-\url{http : //www.euclideanspace.com/maths/standards/program/mycode/graph/tutorial/defuse/index.htm}
+\url{http://www.euclideanspace.com/prog/scratchpad/mycode/graph/tutorial/defuse/}
 
 \section{Drawing Plots and grids}
 The following constructors create 'compound' nodes in that the node
@@ -784,8 +784,8 @@ where a variable (in this case def : Matrix) is a constant in the function?
 \item Support interaction with the graphics, possibly by using a OpenGL
   canvas which could be called directly from SPAD
   Bill Page mentioned that there is an OpenGL binding for lisp.
-  \url{http : //common-lisp.net/project/cl-opengl/}
-  \url{http : //repo.or.cz/w/cl-glfw.git}
+  \url{http://common-lisp.net/project/cl-opengl/}
+  \url{http://repo.or.cz/w/cl-glfw.git}
 \end{itemize}
 \section{SPointCategory}
 SPointCategory defines a type that can represent either a point or a vector.
@@ -835,7 +835,7 @@ this but decided not to because:
 ++ AMS Classifications:
 ++ Keywords:
 ++ References:
-++ http: //www.euclideanspace.com/maths/standards/program/mycode/graph/
+++ http://www.euclideanspace.com/prog/scratchpad/mycode/graph/
 ++ Description: PointCategory is the category of points and vectors in space.
 ++ Points may be used to represent shapes in a scenegraph such as: the
 ++ vertices of a cube or points along a line.
@@ -1028,7 +1028,7 @@ distinguish between points and vectors.
 ++ AMS Classifications:
 ++ Keywords:
 ++ References:
-++ http: //www.euclideanspace.com/maths/standards/program/mycode/graph/
+++ http://www.euclideanspace.com/prog/scratchpad/mycode/graph/
 ++ Description: an implementation of PointCategory to represent points and
 ++ vectors in three dimensional coordinate space
 
@@ -1323,7 +1323,7 @@ dimensional points and vectors on Argand plane.
 ++ AMS Classifications:
 ++ Keywords:
 ++ References:
-++ http: //www.euclideanspace.com/maths/standards/program/mycode/graph/
+++ http://www.euclideanspace.com/prog/scratchpad/mycode/graph/
 ++ Description: an implementation of PointCategory to represent points and
 ++ vectors in an Argand plane
 
@@ -1539,7 +1539,7 @@ A coding of points and vectors in conformal space.
 ++ AMS Classifications:
 ++ Keywords:
 ++ References:
-++ http: //www.euclideanspace.com/maths/standards/program/mycode/graph/
+++ http://www.euclideanspace.com/prog/scratchpad/mycode/graph/
 ++ Description: an implementation of PointCategory to represent points and
 ++ vectors in n+2 dimensional conformal space based on n dimensional
 ++ Euclidean space.
@@ -2204,7 +2204,7 @@ We can then use this 'named points' domain in the scene like this:
                                                                    Type : Void
 \end{verbatim}
 Further information here:
-\url{http : //www.euclideanspace.com/maths/standards/program/mycode/graph/tutorial/named/index.htm}
+\url{http://www.euclideanspace.com/prog/scratchpad/mycode/graph/tutorial/named/}
 \section{domain SceneNamedPoints}
 )endif
 
@@ -2954,7 +2954,7 @@ such as reflection in unit circle:
 ++ AMS Classifications:
 ++ Keywords:
 ++ References:
-++ http: //www.euclideanspace.com/maths/standards/program/mycode/graph/
+++ http://www.euclideanspace.com/prog/scratchpad/mycode/graph/
 ++ Description:
 ++ This domain implements transforms from SPoint to SPoint
 
@@ -3343,7 +3343,7 @@ inside the boundary.
 ++ AMS Classifications:
 ++ Keywords:
 ++ References:
-++ http: //www.euclideanspace.com/maths/standards/program/mycode/graph/
+++ http://www.euclideanspace.com/prog/scratchpad/mycode/graph/
 ++ Description:
 ++ This domain implements boundaries for use in scene graph
 
@@ -3734,7 +3734,7 @@ function we can support two formats without too much duplication.
 ++ AMS Classifications:
 ++ Keywords:
 ++ References:
-++ http: //www.euclideanspace.com/maths/standards/program/mycode/graph/
+++ http://www.euclideanspace.com/prog/scratchpad/mycode/graph/
 ++ Description:
 ++ This package provides support for XML files
 ++ XML attributes are inside the opening tag:
@@ -3802,7 +3802,7 @@ XmlAttribute() : Exports==Implementation where
 ++ AMS Classifications:
 ++ Keywords:
 ++ References:
-++ http: //www.euclideanspace.com/maths/standards/program/mycode/graph/
+++ http://www.euclideanspace.com/prog/scratchpad/mycode/graph/
 ++ Description:
 ++ This package provides support for XML files
 ++ an XML element is something which either has the form:
@@ -3918,7 +3918,7 @@ XmlElement() : Exports==Implementation where
 ++ AMS Classifications:
 ++ Keywords:
 ++ References:
-++ http: //www.euclideanspace.com/maths/standards/program/mycode/graph/
+++ http://www.euclideanspace.com/prog/scratchpad/mycode/graph/
 ++ Description:
 ++ This package provides support for XML files
 
@@ -4016,11 +4016,12 @@ object.
 ++ AMS Classifications:
 ++ Keywords:
 ++ References:
-++ http: //www.euclideanspace.com/maths/standards/program/mycode/graph/
+++ http://www.euclideanspace.com/prog/scratchpad/mycode/graph/
 
 Scene(PT) : Exports == Implementation where
  PT : SPointCategory
 
+ x<<y ==> hconcat(x::OutputForm,y::OutputForm)
  TR ==> STransform PT
  I ==> Integer
  C ==> Complex DoubleFloat
@@ -4162,6 +4163,23 @@ Scene(PT) : Exports == Implementation where
   addSceneLine : (n : %, st : %, en : %, fontScale : DF) -> %
     ++ addSceneLine(n, st, en, fontScale) is a convenience function which
     ++ combines createSceneLine with addChild!
+  createSceneLine : (st : %, en : %, fontScale : DF, shortenLine:Boolean) -> %
+    ++ createSceneLine(st, en, fontScale) constructs a line node, this contains
+    ++ a line, in n-dimensions, from st to en.
+    ++ 'st' and 'en' are nodes in the scene and the line will be drawn
+    ++ upto their boundary.
+    ++ st is the node at the start of the line
+    ++ en is the node at the end of the line
+    ++ fontScale should be set to the full width of the diagram (not
+    ++ just the width of this node). If this is not known then choose
+    ++ an approximate value. This only affects text nodes, if st or en,
+    ++ or its subnodes, do not contain a text node then its
+    ++ value is not significant.
+    ++ shortenLine if true line drawn upto boundary rather than
+    ++             centre of destination.
+  addSceneLine : (n : %, st : %, en : %, fontScale : DF, shortenLine:Boolean) -> %
+    ++ addSceneLine(n, st, en, fontScale) is a convenience function which
+    ++ combines createSceneLine with addChild!
   createSceneLines : (line : LINES) -> %
     ++ createSceneLines(line) constructs a line node, this contains lines
     ++ (represented by a list of points) in n-dimensional space.
@@ -4681,16 +4699,38 @@ Scene(PT) : Exports == Implementation where
   -- st is the node at the start of the arrow
   -- en is the node at the end of the arrow
   createSceneLine(st : %, en : %, fontScale : DF) : % ==
+    createSceneLine(st, en, fontScale, true)
+
+  -- addSceneLine(n, st, en) is a convenience function which
+  -- combines createSceneLine with addChild!
+  addSceneLine(n : %, st : %, en : %, fontScale : DF) : % ==
+    addSceneLine(n , st, en, fontScale, true)
+
+  -- createSceneLine(st, en) constructs a line node, this contains
+  -- a line, in n-dimensions, from st to en.
+  -- 'st' and 'en' are start and end nodes of the line in the scene.
+  -- st is the node at the start of the arrow.
+  -- en is the node at the end of the arrow.
+  -- fontScale allows the boundary of text to be calculated, it should be
+  -- set to the full width of the diagram.
+  -- shortenLine if true line drawn upto boundary rather than
+  --             centre of destination.
+  createSceneLine(st : %, en : %, fontScale : DF, shortenLine:Boolean) : % ==
     stBoundary : SBoundary(PT) := boundary(st, fontScale)
     enBoundary : SBoundary(PT) := boundary(en, fontScale)
-    stPoint := lineIntersect(enBoundary, getCentre(stBoundary))
-    enPoint := lineIntersect(stBoundary, getCentre(enBoundary))
+    stPoint := getCentre(stBoundary)
+    enPoint := getCentre(enBoundary)
+    if shortenLine then
+      stPoint := lineIntersect(enBoundary, stPoint)
+      enPoint := lineIntersect(stBoundary, enPoint)
+    --print("createSceneLine2 start="::OutputForm << stPoint << _
+    --      " end="::OutputForm << enPoint)
     ["LINE"::Symbol,[],[[[stPoint,enPoint]]]]
 
   -- addSceneLine(n, st, en) is a convenience function which
   -- combines createSceneLine with addChild!
-  addSceneLine(n : %, st : %, en : %, fontScale : DF) : % ==
-    c := createSceneLine(st, en, fontScale)
+  addSceneLine(n : %, st : %, en : %, fontScale : DF, shortenLine:Boolean) : % ==
+    c := createSceneLine(st, en, fontScale, shortenLine)
     addChild!(n, c)
     c
 
@@ -5223,7 +5263,7 @@ Scene(PT) : Exports == Implementation where
           d := divide(-x, 10)
           str := concat(["-",string(d.quotient),".",string(d.remainder)])
       else if x ~= 0 then str := concat(str, suffix)
-      addSceneText(gp, str, 20, pz)
+      addSceneText(gp, str, 10, pz)
     gp
 
   -- a convenience function which combines createSceneRuler with
@@ -5583,6 +5623,8 @@ Scene(PT) : Exports == Implementation where
     nodeAtts : List XmlAttribute := []
     -- SVG nodename
     nodeName:String := ""
+    --print("scene toSvg type="::Symbol << n.type << " parameters="::Symbol << _
+    --    n.parameters << " bb="::Symbol << bb << " scale="::Symbol << scale)
     if n.type = "ROOT"::Symbol then -- root node
       nodeName := "svg" -- root node
       -- define arrow shape
@@ -5648,6 +5690,8 @@ Scene(PT) : Exports == Implementation where
         xmlAttribute("stroke-linecap","butt"),_
         xmlAttribute("stroke-linejoin","miter")_
           ]
+      -- print("scene toSVC LINE nodeName="::Symbol << nodeName <<_
+      --     " points="::Symbol << (n.parameters.points))
       if mat2.matOpacity < 0.95::DF then
         nodeAtts := concat(nodeAtts,xmlAttribute("stroke-opacity",_
           (math_to_string mat2.matOpacity)@String))
@@ -5655,12 +5699,16 @@ Scene(PT) : Exports == Implementation where
       if not (n.parameters case shpe) then
         error "toSVG parameter type not valid for shape node"
       param2 := xform(tran, n.parameters.shpe.centre)$TR
-      r2 := xform(tran, n.parameters.shpe.size)$TR
-      --print(hconcat(["scene toSVC SHAPE nodeName="::OutputForm,nodeName::OutputForm,_
-      --     " centre="::OutputForm,(n.parameters.shpe.centre)::OutputForm,_
-      --     " size="::OutputForm,(n.parameters.shpe.size)::OutputForm,_
-      --     " param2="::OutputForm,param2::OutputForm,_
-      --     " r2="::OutputForm,r2::OutputForm]))$OutputForm
+      -- dont transform radius like this:
+      -- r2 := xform(tran, n.parameters.shpe.size)$TR
+      -- because that would translate and we only want to scale
+      r2 := n.parameters.shpe.size
+      --print("scene toSVC SHAPE nodeName="::Symbol << nodeName <<_
+      --     " tran="::Symbol << tran << _
+      --     " centre="::Symbol << (n.parameters.shpe.centre) << _
+      --     " size="::Symbol << (n.parameters.shpe.size) << _
+      --     " param2="::Symbol << param2 << _
+      --     " r2="::Symbol << r2)
       rx : DF := screenCoordX(r2)*scale2
       ry : DF := screenCoordY(r2)*scale2
       nodeName := "ellipse"
@@ -5668,29 +5716,31 @@ Scene(PT) : Exports == Implementation where
       if n.parameters.shpe.shptype = "rect"::Symbol then
         nodeName := "rect"
         sx := "x"; sy := "y"; sw := "width"; sh := "height"
-        param2 := param2 + spnt(0::DF, screenCoordY(r2))$PT
+        -- in all cases param2 is the centre of the shape, so no
+        -- need to offset it
+        --param2 := param2 + spnt(0::DF, screenCoordY(r2))$PT
       if n.parameters.shpe.shptype = "ellipse"::Symbol then
         nodeName := "ellipse"
         sx := "cx"; sy := "cy"; sw := "rx"; sh := "ry"
       if n.parameters.shpe.shptype = "box"::Symbol then
         nodeName := "rect"
         sx := "x"; sy := "y"; sw := "width"; sh := "height"
-        param2 := param2 + spnt(0::DF, screenCoordY(r2))$PT
+        --param2 := param2 + spnt(0::DF, screenCoordY(r2))$PT
       if n.parameters.shpe.shptype = "sphere"::Symbol then
         nodeName := "ellipse"
         sx := "cx"; sy := "cy"; sw := "rx"; sh := "ry"
-      --print(hconcat(["toSVC nodeName="::OutputForm,nodeName::OutputForm,_
-      --     " sx="::OutputForm,sx::OutputForm,(screenCoordX(n.parameters.shpe.centre))::OutputForm,_
-      --     " sy="::OutputForm,sy::OutputForm,(screenCoordY(n.parameters.shpe.centre))::OutputForm,_
-      --     " sw="::OutputForm,sw::OutputForm,(screenCoordX(n.parameters.shpe.size))::OutputForm,_
-      --     " sh="::OutputForm,sh::OutputForm,(screenCoordY(n.parameters.shpe.size))::OutputForm]))$OutputForm
+      --print("toSVC nodeName="::Symbol << nodeName::OutputForm << _
+      --     " sx="::Symbol << sx << (screenCoordX(param2)*scale2) << _
+      --     " sy="::Symbol << sy << (-screenCoordY(param2)*scale2) << _
+      --     " sw="::Symbol << sw << abs(rx) << _
+      --     " sh="::Symbol << sh << abs(ry))
       nodeAtts := [_
         xmlAttribute("stroke",mat2.lineCol),_
         xmlAttribute("stroke-width",(math_to_string mat2.lineWidth)@String),_
         xmlAttribute(sx, (math_to_string (screenCoordX(param2)*scale2))@String), _
         xmlAttribute(sy, (math_to_string (-screenCoordY(param2)*scale2))@String), _
-        xmlAttribute(sw, math_to_string(rx)), _
-        xmlAttribute(sh, math_to_string(ry))_
+        xmlAttribute(sw, math_to_string(abs(rx))), _
+        xmlAttribute(sh, math_to_string(abs(ry)))_
           ]
       if not n.parameters.shpe.fill
        then
@@ -5713,12 +5763,13 @@ Scene(PT) : Exports == Implementation where
         -- use named points
         for nam in n.parameters.text.np repeat
           param2 := xform(tran, findPoint(np2, nam)+n.parameters.text.pos)$TR
-          nodeAttsTxt := [xmlAttribute("font-size",_
-            string(n.parameters.text.siz)), _
+          nodeAttsTxt := [xmlAttribute("font-size",string(n.parameters.text.siz)), _
+            xmlAttribute("transform",_
+            concat(["scale(",math_to_string(scale2/(2::DF))@String,",",math_to_string(scale2/(2::DF))@String,")"])@String), _
             xmlAttribute("x",_
-            (math_to_string (screenCoordX(param2)*scale2))@String), _
+            (math_to_string (screenCoordX(param2)*(2::DF)))@String), _
             xmlAttribute("y",_
-            (math_to_string (-screenCoordY(param2)*scale2))@String), _
+            (math_to_string (-screenCoordY(param2)*(2::DF)))@String), _
             xmlAttribute("style",concat("fill:",mat2.fillCol))_
               ]
           xch : XmlElement := xmlElement(nodeName, nam, nodeAttsTxt)
@@ -5726,11 +5777,22 @@ Scene(PT) : Exports == Implementation where
             nodeEles := concat(nodeEles, xch)
         return xmlElement("g",nodeEles,nodeAtts)
       param2 : PT := xform(tran, n.parameters.text.pos)$TR
+      --print("scene toSvg font-size="::Symbol << n.parameters.text.siz << " scale2="::Symbol << _
+      --  math_to_string(scale2)@String)
+      -- scale text but if screen is very small then limit text epansion so text does not fill
+      -- too large a proportion of the screen
+      textScale:DF := scale2/(2::DF)
+      x:DF := screenCoordX(param2)*(2::DF)
+      y:DF := -screenCoordY(param2)*(2::DF)
+      if textScale > 2::DF then
+        x := x * textScale / (2::DF)
+        y := y * textScale / (2::DF)
+        textScale := 2::DF
       nodeAtts := [xmlAttribute("font-size",string(n.parameters.text.siz)),_
-        xmlAttribute("x",_
-        (math_to_string (screenCoordX(param2)*scale2))@String), _
-        xmlAttribute("y",_
-        (math_to_string (-screenCoordY(param2)*scale2))@String), _
+        xmlAttribute("transform",_
+        concat(["scale(",math_to_string(textScale)@String,",",math_to_string(textScale)@String,")"])@String), _
+        xmlAttribute("x",math_to_string(x)@String), _
+        xmlAttribute("y",math_to_string(y)@String), _
         xmlAttribute("style",concat("fill:",mat2.fillCol))_
           ]
       return xmlElement(nodeName, n.parameters.text.txt, nodeAtts)
@@ -5738,8 +5800,8 @@ Scene(PT) : Exports == Implementation where
       nodeName := "g" -- transform node
       if not (n.parameters case trans) then
         error "toSVG parameter type not valid for trans node"
-      --print(hconcat(["scene toSVC TRANSFORM nodeName="::OutputForm,nodeName::OutputForm,_
-      --     " trans="::OutputForm,n.parameters.trans::OutputForm]))$OutputForm
+      --print("scene toSVC TRANSFORM nodeName="::Symbol << nodeName <<_
+      --     " trans="::Symbol << n.parameters.trans)
       tran2 := compound(n.parameters.trans, tran)
     if n.type = "CLIP"::Symbol then -- set default clip bounding box
       nodeName := "g" -- clip node
@@ -5781,10 +5843,10 @@ Scene(PT) : Exports == Implementation where
               n.parameters.arrw.offset)$TR
       startPointM : DF := -(screenCoordY(startPoint)*scale)
       endPointM : DF := -(screenCoordY(endPoint)*scale)
-      --print(hconcat(["scene toSVG start="::OutputForm,(n.parameters.arrw.st)::OutputForm,_
-      --  " end="::OutputForm,(n.parameters.arrw.en)::OutputForm,_
-      --  " startXfmd="::OutputForm,startPoint::OutputForm,_
-      --  " endXfmd="::OutputForm,endPoint::OutputForm]))$OutputForm
+      --print("scene toSVG start="::Symbol << (n.parameters.arrw.st) << _
+      --  " end="::Symbol << (n.parameters.arrw.en) << _
+      --  " startXfmd="::Symbol << startPoint << _
+      --  " endXfmd="::Symbol << endPoint)
       -- first check if arrow starts and ends at the same place and
       -- if so draw a loop
       if n.parameters.arrw.st = n.parameters.arrw.en
@@ -6689,7 +6751,7 @@ Scene(PT) : Exports == Implementation where
     s
 
 
---Copyright (c) 2010-2012, Martin J Baker.
+--Copyright (c) 2010-2016, Martin J Baker.
 --All rights reserved.
 --
 --Redistribution and use in source and binary forms, with or without
@@ -6730,17 +6792,17 @@ algebra to represent graphical information.
 [2] Doran & Lasenby, 2003 , Geometric Algebra for Physicists,
 ISBN 0521480221
 [3] User Tutorial:
-http : //www.euclideanspace.com/maths/standards/program/mycode/graph/tutorial/
+\url{http://www.euclideanspace.com/prog/scratchpad/mycode/graph/tutorial/}
 [4] User Reference:
-http : //www.euclideanspace.com/maths/standards/program/mycode/graph/userref/
+\url{http://www.euclideanspace.com/prog/scratchpad/mycode/graph/userref/}
 [5] Programmers Reference:
-http : //www.euclideanspace.com/maths/standards/program/mycode/graph/progref/
+\url{http://www.euclideanspace.com/prog/scratchpad/mycode/graph/progref/}
 [6] Examples of scenegraph structure:
-http : //www.euclideanspace.com/maths/standards/program/mycode/graph/examples/
+\url{http://www.euclideanspace.com/prog/scratchpad/mycode/graph/examples/}
 [7] X3D & Related Specifications
-http : //www.web3d.org/x3d/
+\url{http://www.web3d.org/x3d/
 [8] SVG & Related Specifications
-http : //www.w3.org/Graphics/SVG/
+\url{http://www.w3.org/Graphics/SVG/}
 \end{thebibliography}
 \end{document}
-)endif
+)endif
\ No newline at end of file
-- 
2.1.4

