cFiniteGraph`1`x`(SetCategory)->Category`(S)`FGRPH`This is used with graph theory code (FiniteGraph,{} DirectedGraph. FunctionGraph,{} and so on) to represent a loop as either a sequence of vertex or arrow indexes depending on context. The main benefit is that the loop is stored in a canonical way so that loops can be quickly compared using \spad{'='}.
cInternalMessageLevel`0`x`()->Category``IML`For each domain which uses this category we define three internal message level pointers \spad{pF1},{} \spad{pF2},{} \spad{pF3},{} to boolean values,{} default pointers are set to \spad{false}. This gives three message levels 1,{}2,{}3,{} default is 0. The value of the pointers are used as print flags. If a code has statements like "if deref \spad{pF1} then print ...." the users of the domain can dynamically change the message level to get interval inf--------ormations. This can be done by \axiom{setMessageLevel}
cSPointCategory`0`x`()->Category``SPTCAT`PointCategory is the category of points and vectors in space. Points may be used to represent shapes in a scenegraph such as: the vertices of a cube or points along a line. Shapes such as these may be defined explicitly or may be plotted. We implement SetCategory to allow us to curry transforms from one point to another.
dDirectedGraph`1`x`(SetCategory)->Join(FiniteGraph(S),etc)`(S)`DGRPH`This is used with graph theory code (FiniteGraph,{} DirectedGraph. FunctionGraph,{} and so on) to represent a loop as either a sequence of vertex or arrow indexes depending on context. The main benefit is that the loop is stored in a canonical way so that loops can be quickly compared using \spad{'='}.
dFunctionGraph`1`x`(SetCategory)->Join(FiniteGraph(S),etc)`(S)`FNGRPH`This is used with graph theory code (FiniteGraph,{} DirectedGraph. FunctionGraph,{} and so on) to represent a loop as either a sequence of vertex or arrow indexes depending on context. The main benefit is that the loop is stored in a canonical way so that loops can be quickly compared using \spad{'='}.
dLoop`0`x`()->Join(SetCategory,etc)``LOOP`This is used with graph theory code (FiniteGraph,{} DirectedGraph. FunctionGraph,{} and so on) to represent a loop as either a sequence of vertex or arrow indexes depending on context. The main benefit is that the loop is stored in a canonical way so that loops can be quickly compared using \spad{'='}.
dMultifunctionGraph`1`x`(SetCategory)->Join(FiniteGraph(S),etc)`(S)`MFGRPH`This is used with graph theory code (FiniteGraph,{} DirectedGraph. FunctionGraph,{} and so on) to represent a loop as either a sequence of vertex or arrow indexes depending on context. The main benefit is that the loop is stored in a canonical way so that loops can be quickly compared using \spad{'='}.
dSArgand`0`x`()->Join(SPointCategory,etc)``SARGND`PointCategory is the category of points and vectors in space. Points may be used to represent shapes in a scenegraph such as: the vertices of a cube or points along a line. Shapes such as these may be defined explicitly or may be plotted. We implement SetCategory to allow us to curry transforms from one point to another.
dSBoundary`1`x`(SPointCategory)->etc`(PT)`SBOUND`PointCategory is the category of points and vectors in space. Points may be used to represent shapes in a scenegraph such as: the vertices of a cube or points along a line. Shapes such as these may be defined explicitly or may be plotted. We implement SetCategory to allow us to curry transforms from one point to another.
dSCartesian`1`x`(PositiveInteger)->SPointCategory`(n)`SCRT`PointCategory is the category of points and vectors in space. Points may be used to represent shapes in a scenegraph such as: the vertices of a cube or points along a line. Shapes such as these may be defined explicitly or may be plotted. We implement SetCategory to allow us to curry transforms from one point to another.
dSConformal`1`x`(PositiveInteger)->Join(SPointCategory,etc)`(n)`SCONF`PointCategory is the category of points and vectors in space. Points may be used to represent shapes in a scenegraph such as: the vertices of a cube or points along a line. Shapes such as these may be defined explicitly or may be plotted. We implement SetCategory to allow us to curry transforms from one point to another.
dSTransform`1`x`(SPointCategory)->etc`(PT)`STR`PointCategory is the category of points and vectors in space. Points may be used to represent shapes in a scenegraph such as: the vertices of a cube or points along a line. Shapes such as these may be defined explicitly or may be plotted. We implement SetCategory to allow us to curry transforms from one point to another.
dSceneIFS`1`x`(SPointCategory)->etc`(PT)`SCIFS`PointCategory is the category of points and vectors in space. Points may be used to represent shapes in a scenegraph such as: the vertices of a cube or points along a line. Shapes such as these may be defined explicitly or may be plotted. We implement SetCategory to allow us to curry transforms from one point to another.
dSceneNamedPoints`1`x`(SPointCategory)->Join(SetCategory,etc)`(PT)`SCNP`PointCategory is the category of points and vectors in space. Points may be used to represent shapes in a scenegraph such as: the vertices of a cube or points along a line. Shapes such as these may be defined explicitly or may be plotted. We implement SetCategory to allow us to curry transforms from one point to another.
dScene`1`x`(SPointCategory)->etc`(PT)`SCENE`PointCategory is the category of points and vectors in space. Points may be used to represent shapes in a scenegraph such as: the vertices of a cube or points along a line. Shapes such as these may be defined explicitly or may be plotted. We implement SetCategory to allow us to curry transforms from one point to another.
dUndirectedGraph`1`x`(SetCategory)->Join(FiniteGraph(S),etc)`(S)`UDGRPH`This is used with graph theory code (FiniteGraph,{} DirectedGraph. FunctionGraph,{} and so on) to represent a loop as either a sequence of vertex or arrow indexes depending on context. The main benefit is that the loop is stored in a canonical way so that loops can be quickly compared using \spad{'='}.
dVelocitiesToGraph`1`x`(CommutativeRing)->Join(InternalMessageLevel,etc)`(K)`VL2GRP`\indented{1}{Author: Johannes Grabmeier} Date Created: 2016-08-25 Date Last Updated: 2016-08-27 Basic Functions: Related Constructors: Also See: AMS Classifications: Keywords: References: Description:
dWeightedGraph`2`x`(SetCategory,W:OrderedAbelianMonoid)->Join(FiniteGraph(S),etc)`(S,W)`WGRPH`This is used with graph theory code (FiniteGraph,{} DirectedGraph. FunctionGraph,{} and so on) to represent a loop as either a sequence of vertex or arrow indexes depending on context. The main benefit is that the loop is stored in a canonical way so that loops can be quickly compared using \spad{'='}.
dXmlAttribute`0`x`()->etc``XMLAT`PointCategory is the category of points and vectors in space. Points may be used to represent shapes in a scenegraph such as: the vertices of a cube or points along a line. Shapes such as these may be defined explicitly or may be plotted. We implement SetCategory to allow us to curry transforms from one point to another.
dXmlElement`0`x`()->etc``XMLEL`PointCategory is the category of points and vectors in space. Points may be used to represent shapes in a scenegraph such as: the vertices of a cube or points along a line. Shapes such as these may be defined explicitly or may be plotted. We implement SetCategory to allow us to curry transforms from one point to another.
o*`2`x`(DoubleFloat,_$)->_$`cSPointCategory``*(\spad{s},{} \spad{x}) gives scalar multiplication Although,{} scalar multiplication is strictly only a valid operation for vectors and not points,{} we allow it here because there are some useful short cuts,{} for instance,{} to find the central point between two points we can add them together and scalar multiply by 0.5.
o*`2`x`(_$,_$)->DirectedGraph(Product(S,S))`dDirectedGraph(S)``\spad{"*"}(a,{}\spad{b}) returns a tensor product : the tensor product \spad{G*H} of graphs \spad{G} and \spad{H} is a graph such that the vertex set of \spad{G*H} is the Cartesian product \spad{V}(\spad{G}) \times \spad{V}(\spad{H}); and any two vertices (\spad{u},{} u') and (\spad{v},{} \spad{v'}) are adjacent in \spad{G} \times \spad{H} if and only if u' is adjacent with \spad{v'} and \spad{u} is adjacent with \spad{v}.
o*`2`x`(_$,_$)->FunctionGraph(Product(S,S))`dFunctionGraph(S)``tensor product : the tensor product \spad{G*H} of graphs \spad{G} and \spad{H} is a graph such that the vertex set of \spad{G*H} is the Cartesian product \spad{V}(\spad{G}) \times \spad{V}(\spad{H}); and any two vertices (\spad{u},{} u') and (\spad{v},{} \spad{v'}) are adjacent in \spad{G} \times \spad{H} if and only if u' is adjacent with \spad{v'} and \spad{u} is adjacent with \spad{v}. Cartesian product does apply to function grap------h produces two arrows out of every node
o*`2`x`(_$,_$)->MultifunctionGraph(Product(S,S))`dMultifunctionGraph(S)``tensor product : the tensor product \spad{G*H} of graphs \spad{G} and \spad{H} is a graph such that the vertex set of \spad{G*H} is the Cartesian product \spad{V}(\spad{G}) \times \spad{V}(\spad{H}); and any two vertices (\spad{u},{} u') and (\spad{v},{} \spad{v'}) are adjacent in \spad{G} \times \spad{H} if and only if u' is adjacent with \spad{v'} and \spad{u} is adjacent with \spad{v}.
o*`2`x`(_$,_$)->UndirectedGraph(Product(S,S))`dUndirectedGraph(S)``tensor product : the tensor product \spad{G*H} of graphs \spad{G} and \spad{H} is a graph such that the vertex set of \spad{G*H} is the Cartesian product \spad{V}(\spad{G}) \times \spad{V}(\spad{H}); and any two vertices (\spad{u},{} u') and (\spad{v},{} \spad{v'}) are adjacent in \spad{G} \times \spad{H} if and only if u' is adjacent with \spad{v'} and \spad{u} is adjacent with \spad{v}.
o*`2`x`(_$,_$)->WeightedGraph(Product(S,S),W)`dWeightedGraph(S,W)``tensor product : the tensor product \spad{G*H} of graphs \spad{G} and \spad{H} is a graph such that the vertex set of \spad{G*H} is the Cartesian product \spad{V}(\spad{G}) \times \spad{V}(\spad{H}); and any two vertices (\spad{u},{} u') and (\spad{v},{} \spad{v'}) are adjacent in \spad{G} \times \spad{H} if and only if u' is adjacent with \spad{v'} and \spad{u} is adjacent with \spad{v}.
o+`2`x`(_$,_$)->_$`cFiniteGraph(S)``sum : disjoint union of nodes with arrows from appropriate input
o+`2`x`(_$,_$)->_$`cSPointCategory``+(\spad{x},{} \spad{y}) gives addition add the corresponding elements of the vector or point. The type (vector or point) depends on the following table: vector + vector = vector point + vector = point point + point = invalid (but interpret as vector) Although,{} adding two points is not strictly a valid operation,{} we allow it here by interpreting the point as a vector relative to the origin. We do that because there are some useful short cuts,{} for instance------------------------,{} to find the central point between two points we can add them together and scalar multiply by 0.5.
o-`2`x`(_$,_$)->_$`cSPointCategory``\spad{-(x,{} y)} gives subtraction subtract the corresponding elements of the vector or point. The type (vector or point) depends on the following table: vector - vector = vector point - vector = point vector - point = invalid (but interpret as point) point - point = invalid (but interpret as vector) Although,{} subtracting two points is not strictly a valid operation,{} we allow it here by interpreting the result as the vector distance between the two points.
o=`2`x`(A,A)->Boolean`xFiniteGraph&(A,S)``
oPnan?`1`x`(_$)->Boolean`cSPointCategory``\spad{Pnan?(p)} returns \spad{true} if any of its elements are not valid DoubleFloat values. Examples of invalid floating point numbers are when we have divided a given element by zero or taken sqrt of negative number at some stage? Note: we can still represent a point at infinity and we can represent points using complex numbers,{} but we do this using projective or conformal space or by using the appropriate instance of SPointCategory,{} not by using i------------------------nvalid floating point numbers.
oaddArrow!`2`x`(A,Record(name:String,arrType:NonNegativeInteger,fromOb:NonNegativeInteger,toOb:NonNegativeInteger,xOffset:Integer,yOffset:Integer,map:List(NonNegativeInteger)))->A`xFiniteGraph&(A,S)``
oaddArrow!`2`x`(_$,Record(name:String,arrType:NonNegativeInteger,fromOb:NonNegativeInteger,toOb:NonNegativeInteger,xOffset:Integer,yOffset:Integer,map:List(NonNegativeInteger)))->_$`cFiniteGraph(S)``\spad{addArrow!(s,{} ar)} adds an arrow ar to the graph \spad{s}
oaddArrow!`4`x`(A,String,NonNegativeInteger,NonNegativeInteger)->A`xFiniteGraph&(A,S)``
oaddArrow!`4`x`(A,String,S,S)->A`xFiniteGraph&(A,S)``
oaddArrow!`4`x`(_$,String,NonNegativeInteger,NonNegativeInteger)->_$`cFiniteGraph(S)``\spad{addArrow!(s,{} nm,{} n1,{} n2)} adds an arrow to the graph \spad{s},{} where: \spad{nm} is the name of the arrow \spad{n1} is the index of the start object \spad{n2} is the index of the end object
oaddArrow!`4`x`(_$,String,S,S)->_$`cFiniteGraph(S)``\spad{addArrow!(s,{} nm,{} o1,{} o2)} adds an arrow to the graph \spad{s},{} where: \spad{nm} is the name of the arrow \spad{o1} is the start object \spad{o2} is the end object
oaddArrow!`5`x`(A,String,NonNegativeInteger,NonNegativeInteger,List(NonNegativeInteger))->A`xFiniteGraph&(A,S)``
oaddArrow!`5`x`(_$,String,NonNegativeInteger,NonNegativeInteger,List(NonNegativeInteger))->_$`cFiniteGraph(S)``\spad{addArrow!(s,{} nm,{} n1,{} n2,{} mp)} adds an arrow to the graph \spad{s},{} where: \spad{nm} is the name of the arrow \spad{n1} is the index of the start object \spad{n2} is the index of the end object \spad{mp} is a map represented by this arrow
oaddArrows2Din2D`5`x`(_$,(PT)->PT,Segment(DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->_$`dScene(PT)``\spad{addArrows2Din2D(n,{} ptFun,{} uSeg,{} vSeg,{} numPts)} is a convenience function which combines createArrows2Din2D with addChild!
oaddChild!`2`x`(_$,_$)->Void`dScene(PT)``\spad{addChild!(n,{} c)} adds the specified child node \spad{'c'} below node \spad{'n'}
oaddNode!`3`x`(_$,String,Scene(PT))->_$`dSceneNamedPoints(PT)``\spad{addNode!(n,{} ptName,{} sc)} adds a scene node.
oaddObject!`2`x`(_$,Record(value:S,posX:NonNegativeInteger,posY:NonNegativeInteger))->_$`cFiniteGraph(S)``\spad{addObject!(s,{} n)} adds object with coordinates \spad{n} to the graph \spad{s}.
oaddObject!`2`x`(_$,S)->_$`cFiniteGraph(S)``\spad{addObject!(s,{} n)} adds object \spad{n} to the graph \spad{s}. Use this version if you don\spad{'t} intend to create diagrams and therefore don\spad{'t} care about \spad{x},{} \spad{y} coordinates.
oaddPlot1Din2D`4`x`(_$,(DoubleFloat)->DoubleFloat,Segment(DoubleFloat),NonNegativeInteger)->_$`dScene(PT)``\spad{addPlot1Din2D(n,{} f,{} tRange,{} numPts)} is a convenience function which combines createPlot1Din2D with addChild!
oaddPlot1Din2D`4`x`(_$,(DoubleFloat)->PT,Segment(DoubleFloat),NonNegativeInteger)->_$`dScene(PT)``\spad{addPlot1Din2D(n,{} f,{} tRange,{} numPts)} is a convenience function which combines createPlot1Din2D with addChild!
oaddPlot1Din2Dparametric`4`x`(_$,ParametricPlaneCurve((DoubleFloat)->DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->_$`dScene(PT)``\spad{addPlot1Din2Dparametric(n,{} ppc,{} tRange,{} numPts)} is a convenience function which combines createPlot1Din2Dparametric with addChild!
oaddPlot1Din3Dparametric`4`x`(_$,(DoubleFloat)->PT,Segment(DoubleFloat),NonNegativeInteger)->_$`dScene(PT)``\spad{addPlot1Din3Dparametric(n,{} pcfun,{} tRange,{} numPts)} is a convenience function which combines createPlot1Din3Dparametric with addChild!
oaddPlot1Din3Dparametric`4`x`(_$,ParametricSpaceCurve((DoubleFloat)->DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->_$`dScene(PT)``\spad{addPlot1Din3Dparametric(n,{} psc,{} tRange,{} numPts)} is a convenience function which combines createPlot1Din3Dparametric with addChild!
oaddPlot2Din3D`5`x`(_$,(DoubleFloat,DoubleFloat)->DoubleFloat,Segment(DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->_$`dScene(PT)``\spad{addPlot2Din3D(n,{} f,{} uSeg,{} vSeg,{} numPts)} is a convenience function which combines createPlot2Din3D with addChild!
oaddPlot2Din3Dparametric`5`x`(_$,(DoubleFloat,DoubleFloat)->PT,Segment(DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->_$`dScene(PT)``\spad{addPlot2Din3Dparametric(n,{} f,{} uSeg,{} vSeg,{} numPts)} is a convenience function which combines createPlot2Din3Dparametric with addChild!
oaddPlot2Din3Dparametric`5`x`(_$,ParametricSurface((DoubleFloat,DoubleFloat)->DoubleFloat),Segment(DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->_$`dScene(PT)``\spad{addPlot2Din3Dparametric(n,{} f,{} uSeg,{} vSeg,{} numPts)} is a convenience function which combines createPlot2Din3Dparametric with addChild!
oaddPoints!`3`x`(_$,String,_$)->_$`dSceneNamedPoints(PT)``\spad{addPoints!(n,{} ptName,{} pts)} adds a points node.
oaddRectangle!`2`x`(UndirectedGraph(Integer),List(Integer))->UndirectedGraph(Integer)`dVelocitiesToGraph(K)``\spad{addRectangle!(vP,{} rec)} assumes that rec ist a rectangle,{} \spadignore{i.e.} consisting of 4 vertices [\spad{i},{}\spad{j},{}\spad{k},{}\spad{l}] describing the diagonals \spad{i}-\spad{j} and \spad{k}-\spad{l}. It adds the vertices \spad{i}-\spad{l},{} \spad{i}-\spad{l},{} \spad{j}-\spad{k},{} \spad{j}-\spad{l} and can be used not only for rectangles!
oaddSceneArrow`6`x`(_$,String,String,PT,Symbol,DoubleFloat)->_$`dScene(PT)``\spad{addSceneArrow(n,{} st,{} en,{} offset,{} mode,{} size)} is a convenience function which combines createSceneArrow with addChild!
oaddSceneArrow`7`x`(_$,_$,_$,PT,Symbol,DoubleFloat,DoubleFloat)->_$`dScene(PT)``\spad{addSceneArrow(n,{} st,{} en,{} offset,{} mode,{} size,{} fontScale)} is a convenience function which combines createSceneArrow with addChild!
oaddSceneArrows`4`x`(_$,List(List(PT)),Symbol,DoubleFloat)->_$`dScene(PT)``\spad{addSceneArrows(n,{} line,{} mode,{} size)} is a convenience function which combines createSceneArrows with addChild!
oaddSceneBox`2`x`(_$,DoubleFloat)->_$`dScene(PT)``\spad{addSceneBox(n,{} size)} is a convenience function which combines createSceneBox with addChild!
oaddSceneClip`2`x`(_$,Record(mins:PT,maxs:PT))->_$`dScene(PT)``deprecated: this has been superseded by version with SBoundary(\spad{PT}) do not use,{} may be removed in the future.
oaddSceneClip`2`x`(_$,SBoundary(PT))->_$`dScene(PT)``\spad{addSceneClip(n,{} bb)} is a convenience function which combines createSceneClip with addChild!
oaddSceneDef`3`x`(_$,String,_$)->_$`dScene(PT)``\spad{addSceneDef(n,{} nam,{} nde)} is a convenience function which combines createSceneDef with addChild!
oaddSceneGraph`5`x`(_$,DirectedGraph(String),NonNegativeInteger,NonNegativeInteger,Boolean)->_$`dScene(PT)``\spad{addSceneGraph(n,{} g,{} x,{} y,{} dispArrowName)} is a convenience function which combines createSceneGraph with addChild!
oaddSceneGrid`2`x`(_$,Record(mins:PT,maxs:PT))->_$`dScene(PT)``deprecated: this has been superseded by version with SBoundary(\spad{PT}) do not use,{} may be removed in the future.
oaddSceneGrid`2`x`(_$,SBoundary(PT))->_$`dScene(PT)``\spad{addSceneGrid(n,{} bb)} is a convenience function which combines createSceneGrid with addChild!
oaddSceneGrid`3`x`(_$,DoubleFloat,Record(mins:PT,maxs:PT))->_$`dScene(PT)``deprecated: this has been superseded by version with SBoundary(\spad{PT}) do not use,{} may be removed in the future.
oaddSceneGrid`3`x`(_$,DoubleFloat,SBoundary(PT))->_$`dScene(PT)``\spad{addSceneGrid(n,{} stepSize,{} bb)} is a convenience function which combines createSceneGrid with addChild!
oaddSceneGroup`1`x`(_$)->_$`dScene(PT)``\spad{addSceneGroup(n)} is a convenience function which combines createSceneGroup with addChild!
oaddSceneIFS`2`x`(_$,SceneIFS(PT))->_$`dScene(PT)``\spad{addSceneIFS(n,{} in1)} is a convenience function which combines createSceneIFS with addChild!
oaddSceneIFS`3`x`(_$,List(List(NonNegativeInteger)),List(PT))->_$`dScene(PT)``\spad{addSceneIFS(n,{} inx,{} pts)} is a convenience function which combines createSceneIFS with addChild!
oaddSceneLine`2`x`(_$,List(PT))->_$`dScene(PT)``\spad{addSceneLine(n,{} line)} is a convenience function which combines createSceneLine with addChild!
oaddSceneLine`4`x`(_$,_$,_$,DoubleFloat)->_$`dScene(PT)``\spad{addSceneLine(n,{} st,{} en,{} fontScale)} is a convenience function which combines createSceneLine with addChild!
oaddSceneLines`2`x`(_$,List(List(PT)))->_$`dScene(PT)``\spad{addSceneLines(n,{} line)} is a convenience function which combines createSceneLines with addChild!
oaddSceneMaterial`2`x`(_$,Record(lineWidth:DoubleFloat,lineCol:String,fillCol:String,matOpacity:DoubleFloat))->_$`dScene(PT)``\spad{addSceneMaterial(n,{} mat)} is a convenience function which combines createSceneMaterial with addChild!
oaddSceneMaterial`4`x`(_$,DoubleFloat,String,String)->_$`dScene(PT)``\spad{addSceneMaterial(n,{} lineW,{} lineC,{} fillC)} is a convenience function which combines createSceneMaterial with addChild!
oaddSceneNamedPoints`2`x`(_$,SceneNamedPoints(PT))->_$`dScene(PT)``\spad{addSceneNamedPoints(n,{} np)} is a convenience function which combines createSceneNamedPoints with addChild!
oaddScenePattern`4`x`(_$,Symbol,NonNegativeInteger,Record(mins:PT,maxs:PT))->_$`dScene(PT)``deprecated: this has been superseded by version with SBoundary(\spad{PT}) do not use,{} may be removed in the future.
oaddScenePattern`4`x`(_$,Symbol,NonNegativeInteger,SBoundary(PT))->_$`dScene(PT)``\spad{addScenePattern(n,{} ptype,{} step,{} bb)} is a convenience function which combines createScenePattern with addChild!
oaddSceneRuler`4`x`(_$,Symbol,PT,Record(mins:PT,maxs:PT))->_$`dScene(PT)``deprecated: this has been superseded by version with SBoundary(\spad{PT}) do not use,{} may be removed in the future.
oaddSceneRuler`4`x`(_$,Symbol,PT,SBoundary(PT))->_$`dScene(PT)``\spad{addSceneRuler(n,{} ptype,{} offset,{} bb)} is a convenience function which combines createSceneRuler with addChild!
oaddSceneShape`2`x`(_$,Record(shptype:Symbol,centre:PT,size:PT,fill:Boolean))->_$`dScene(PT)``\spad{addSceneShape(n,{} shape)} is a convenience function which combines createSceneShape with addChild!
oaddSceneShape`2`x`(_$,SBoundary(PT))->_$`dScene(PT)``\spad{addSceneShape(n,{} shape)} is a convenience function which combines createSceneShape with addChild!
oaddSceneText`2`x`(_$,Record(txt:String,siz:NonNegativeInteger,pos:PT,np:List(String)))->_$`dScene(PT)``\spad{addSceneText(n,{} text)} is a convenience function which combines createSceneText with addChild!
oaddSceneText`4`x`(_$,List(String),NonNegativeInteger,PT)->_$`dScene(PT)``\spad{addSceneText(n,{} str,{} sz,{} pz)} is a convenience function which combines createSceneText with addChild!
oaddSceneText`4`x`(_$,String,NonNegativeInteger,PT)->_$`dScene(PT)``\spad{addSceneText(n,{} str,{} sz,{} pz)} is a convenience function which combines createSceneText with addChild!
oaddSceneTransform`2`x`(_$,STransform(PT))->_$`dScene(PT)``\spad{addSceneTransform(n,{} tran)} is a convenience function which combines createSceneTransform with addChild!
oaddSceneUse`2`x`(_$,String)->_$`dScene(PT)``\spad{addSceneUse(n,{} nam)} is a convenience function which combines createSceneUse with addChild!
oaddWArrow!`5`x`(_$,String,NonNegativeInteger,NonNegativeInteger,W)->_$`dWeightedGraph(S,W)``\spad{addWArrow!(s,{} name,{} n1,{} n2,{} w)} adds a weighted arrow to the graph \spad{s},{} where \spad{name} is \spad{name} of the arrow,{} \spad{w} is weight of the arrow,{} \spad{n1} is starting point of the arrow,{} \spad{n2} is endpoint of the arrow.
oadjacencyMatrix`1`x`(A)->Matrix(NonNegativeInteger)`xFiniteGraph&(A,S)``
oadjacencyMatrix`1`x`(_$)->Matrix(NonNegativeInteger)`cFiniteGraph(S)``\spad{adjacencyMatrix(s)} returns an \spad{n} by \spad{n} matrix A,{} where \spad{n} is the number of vertices in the graph. If there is an edge from a vertex \spad{x} to a vertex \spad{y},{} then the element ax,{} \spad{y} is 1 (or in general the number of xy edges),{} otherwise it is 0. In computing,{} this matrix makes it easy to find subgraphs,{} and to reverse a directed graph.
oapply`2`x`(_$,NonNegativeInteger)->NonNegativeInteger`dFunctionGraph(S)``\spad{apply '}function' represented by this graph to vertex index 'a'
oapply`3`x`(_$,NonNegativeInteger,NonNegativeInteger)->NonNegativeInteger`dMultifunctionGraph(S)``\spad{apply '}function' represented by this graph to vertex index 'a'
oarrowName`3`x`(A,NonNegativeInteger,NonNegativeInteger)->String`xFiniteGraph&(A,S)``
oarrowName`3`x`(_$,NonNegativeInteger,NonNegativeInteger)->String`cFiniteGraph(S)``\spad{arrowName(s,{} a,{} b)} retrieves the name of arrow a-\spad{>b} if it does not exist then return \spad{"?"}
oarrowsFromArrow`2`x`(A,NonNegativeInteger)->List(NonNegativeInteger)`xFiniteGraph&(A,S)``
oarrowsFromArrow`2`x`(_$,NonNegativeInteger)->List(NonNegativeInteger)`cFiniteGraph(S)``index of all arrows leading to a given arrow
oarrowsFromNode`2`x`(A,NonNegativeInteger)->List(NonNegativeInteger)`xFiniteGraph&(A,S)``
oarrowsFromNode`2`x`(_$,NonNegativeInteger)->List(NonNegativeInteger)`cFiniteGraph(S)``\spad{arrowsFromNode(s,{} a)} gives list of all arrows leading to a given node
oarrowsToArrow`2`x`(A,NonNegativeInteger)->List(NonNegativeInteger)`xFiniteGraph&(A,S)``
oarrowsToArrow`2`x`(_$,NonNegativeInteger)->List(NonNegativeInteger)`cFiniteGraph(S)``arrowsToArrow: (\spad{s:} \%,{} a: NNI) returns index of all arrows leading from a given arrow
oarrowsToNode`2`x`(A,NonNegativeInteger)->List(NonNegativeInteger)`xFiniteGraph&(A,S)``
oarrowsToNode`2`x`(_$,NonNegativeInteger)->List(NonNegativeInteger)`cFiniteGraph(S)``\spad{arrowsToNode(s,{} a)} gives list of all arrows leading from a given node
oboundary`2`x`(_$,DoubleFloat)->SBoundary(PT)`dScene(PT)``\spad{boundary(n,{} fontScale)} returns the boundary of a given node,{} so if this is called on the root node,{} it will return the boundary of the whole scene. There is a difficulty involving text nodes,{} that is they have a fixed font size. But we want to calculate the boundary in local coordinates,{} to do this conversion we need to know the total boundary size but that is what we are trying to calculate! To get round this contradicti------------------------on the parameter fontScale is required since fonts are rendered at a fixed size we need a scaling factor so that we can give the boundary in our coordinate system. fontScale should be set to the full width of the diagram (not just the width of this node). If this is not known then choose an approximate value. This only affects text nodes,{} if this node,{} or its subnodes,{} do not contain a text node then its value is not significant.
oboxBoundary`2`x`(PT,PT)->_$`dSBoundary(PT)``\spad{boxBoundary(c1,{} c2)} constructs a box boundary (\spad{n}-dimensional axis-aligned rectangle) with given parameters \spad{c1:} \spad{PT} holds minimum coordinates \spad{c2:} \spad{PT} holds maximum coordinates
ocartesian`2`x`(_$,_$)->DirectedGraph(Product(S,S))`dDirectedGraph(S)``\spad{cartesian(a,{} b)} returns a Cartesian product: the vertex set of \spad{G} \spad{o} \spad{H} is the Cartesian product \spad{V}(\spad{G}) \times \spad{V}(\spad{H}) and any two vertices (\spad{u},{} u') and (\spad{v},{} \spad{v'}) \indented{1}{are adjacent in \spad{G} \spad{o} \spad{H} if and only if either} \spad{u} = \spad{v} and u' is adjacent with \spad{v'} in \spad{H},{} or u' = \spad{v'} and \spad{u} is adjacent wit------h \spad{v} in \spad{G}.
ocartesian`2`x`(_$,_$)->MultifunctionGraph(Product(S,S))`dMultifunctionGraph(S)``Cartesian product doubles the size of next list in each object,{} that is it produces two arrows out of every node
ocartesian`2`x`(_$,_$)->UndirectedGraph(Product(S,S))`dUndirectedGraph(S)``Cartesian product: the vertex set of \spad{G} \spad{o} \spad{H} is the Cartesian product \spad{V}(\spad{G}) \times \spad{V}(\spad{H}) and any two vertices (\spad{u},{} u') and (\spad{v},{} \spad{v'}) \indented{1}{are adjacent in \spad{G} \spad{o} \spad{H} if and only if either} \spad{u} = \spad{v} and u' is adjacent with \spad{v'} in \spad{H},{} or u' = \spad{v'} and \spad{u} is adjacent with \spad{v} in \spad{G}.
ocartesian`2`x`(_$,_$)->WeightedGraph(Product(S,S),W)`dWeightedGraph(S,W)``Cartesian product: the vertex set of \spad{G} \spad{o} \spad{H} is the Cartesian product \spad{V}(\spad{G}) \times \spad{V}(\spad{H}) and any two vertices (\spad{u},{} u') and (\spad{v},{} \spad{v'}) \indented{1}{are adjacent in \spad{G} \spad{o} \spad{H} if and only if either} \spad{u} = \spad{v} and u' is adjacent with \spad{v'} in \spad{H},{} or u' = \spad{v'} and \spad{u} is adjacent with \spad{v} in \spad{G}.
oclosedCartesian`3`x`(_$,_$,(S,S)->S)->_$`dDirectedGraph(S)``\spad{closedCartesian(a,{} b,{} f)} builds Cartesian product of a and \spad{b} and then maps it back to \% using \spad{f}.
oclosedCartesian`3`x`(_$,_$,(S,S)->S)->_$`dMultifunctionGraph(S)``Cartesian product doubles the size of next list in each object,{} that is it produces two arrows out of every node
oclosedCartesian`3`x`(_$,_$,(S,S)->S)->_$`dUndirectedGraph(S)``as Cartesian product but returns \%.
oclosedCartesian`3`x`(_$,_$,(S,S)->S)->_$`dWeightedGraph(S,W)``as Cartesian product but returns \%.
oclosedTensor`3`x`(_$,_$,(S,S)->S)->_$`dDirectedGraph(S)``\spad{closedTensor(a,{} b,{} f)} builds tensor product of a and \spad{b} and then maps it back to \% using \spad{f}.
oclosedTensor`3`x`(_$,_$,(S,S)->S)->_$`dFunctionGraph(S)``as tensor product but returns \%. Cartesian product does apply to function graph produces two arrows out of every node
oclosedTensor`3`x`(_$,_$,(S,S)->S)->_$`dMultifunctionGraph(S)``as tensor product but returns \%.
oclosedTensor`3`x`(_$,_$,(S,S)->S)->_$`dUndirectedGraph(S)``as tensor product but returns \%.
oclosedTensor`3`x`(_$,_$,(S,S)->S)->_$`dWeightedGraph(S,W)``as tensor product but returns \%.
ocoAdjoint`2`x`(_$,List(NonNegativeInteger))->Union(List(NonNegativeInteger),"failed")`dFunctionGraph(S)``given a mapping from this graph this function tries to calculate a unique reverse mapping back to this graph
ocoAdjoint`2`x`(_$,List(NonNegativeInteger))->Union(List(NonNegativeInteger),"failed")`dMultifunctionGraph(S)``given a mapping from this graph this function tries to calculate a unique reverse mapping back to this graph
ocoerce`1`x`(A)->OutputForm`xFiniteGraph&(A,S)``
ocoerce`1`x`(Complex(DoubleFloat))->_$`dSArgand``
ocoerce`1`x`(List(S))->_$`dDirectedGraph(S)``\spad{coerce List} to graph
ocoerce`1`x`(PermutationGroup(S))->_$`dDirectedGraph(S)``\spad{coerce PermutationGroup} to graph
ocoerce`1`x`(PermutationGroup(S))->_$`dMultifunctionGraph(S)``\spad{coerce PermutationGroup} to graph which represents the generators of the group
ocoerce`1`x`(_$)->Complex(DoubleFloat)`dSArgand``
ocoerce`1`x`(_$)->List(String)`dXmlElement``\spad{coerce(x)} outputs \spad{x} as a list of strings. Each element in the list represents a new line. This is an alternative to creating a long single string with 'newline' embedded in it.
ocoerce`1`x`(_$)->OutputForm`cSPointCategory``output
ocoerce`1`x`(_$)->OutputForm`dSBoundary(PT)``\spad{coerce(bd)} outputs description of \spad{bd} as formatted text
ocoerce`1`x`(_$)->OutputForm`dSTransform(PT)``\spad{coerce(tr)} output
ocoerce`1`x`(_$)->OutputForm`dScene(PT)``output a full scenegraph could contain a lot of data and so we have to be careful to restrict the output to what is reasonable on the command line. Therefore we do not display all subnodes or the full information from nodes such as IFS.
ocoerce`1`x`(_$)->OutputForm`dSceneIFS(PT)``\spad{coerce(me)} list this instance to the command line
ocoerce`1`x`(_$)->String`dXmlAttribute``\spad{coerce(x)} outputs \spad{x} as a string
ocolinearity`2`x`(S,S)->DoubleFloat`xSPointCategory&(S)``
ocolinearity`2`x`(_$,_$)->DoubleFloat`cSPointCategory``\spad{colinearity(x,{} y)} returns a measure of how parallel two vectors are independent of the length of the vectors: 1.0 is completely parallel 0.0 is completely perpendicular returned value will be between these
ocompound`2`x`(_$,_$)->_$`dSTransform(PT)``\spad{compound(tr,{} inpt)} combine two transforms
ocontainsPoint?`2`x`(_$,PT)->Boolean`dSBoundary(PT)``\spad{containsPoint?(n,{} p)} returns \spad{true} if the point is inside \indented{2}{the boundary.} \spad{n} is the boundary \spad{p} is the point
ocontraAdjoint`2`x`(_$,List(NonNegativeInteger))->Union(List(NonNegativeInteger),"failed")`dFunctionGraph(S)``given a mapping from this graph this function tries to calculate a unique reverse mapping back to this graph
ocontraAdjoint`2`x`(_$,List(NonNegativeInteger))->Union(List(NonNegativeInteger),"failed")`dMultifunctionGraph(S)``given a mapping from this graph this function tries to calculate a unique reverse mapping back to this graph
ocreateArrows2Din2D`4`x`((PT)->PT,Segment(DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->_$`dScene(PT)``\spad{createArrows2Din2D(ptFun,{} uSeg,{} vSeg,{} numPts)} creates arrows to represent output for each input point in other words this represents a two dimensional force field with the arrows showing the direction of the field
ocreatePlot1Din2D`3`x`((DoubleFloat)->DoubleFloat,Segment(DoubleFloat),NonNegativeInteger)->_$`dScene(PT)``\spad{createPlot1Din2D(f,{} tRange,{} numPts)} creates two dimensional function plot. Draws the graph of \spad{y} = \spad{f}(\spad{x}) as \spad{x} ranges from min(a,{} \spad{b}) to max(a,{} \spad{b}). \spad{tRange} is a..\spad{b}
ocreatePlot1Din2D`3`x`((DoubleFloat)->PT,Segment(DoubleFloat),NonNegativeInteger)->_$`dScene(PT)``\spad{createPlot1Din2D(f,{} tRange,{} numPts)} creates a two dimensional function plot draws the graph from a mapping of float to point as \spad{x} ranges from min(a,{} \spad{b}) to max(a,{} \spad{b}). \spad{tRange} is a..\spad{b}
ocreatePlot1Din2Dparametric`3`x`(ParametricPlaneCurve((DoubleFloat)->DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->_$`dScene(PT)``\spad{createPlot1Din2Dparametric(ppc,{} tRange,{} numPts)} creates a node from plot using Parametric Plane Curve. This represents 1 dimension (line - possibly curved) in 2 dimensions (plane) In theory a line has no width but in that case we would not see it so we give it a width given by the material node that is applicable in this part of the scene graph \sp------------------------ad{PPC} is ParametricPlaneCurve(\spad{DF} \spad{->} \spad{DF}) which is created with curve(\spad{f1},{} \spad{f2}) where \spad{f1} and \spad{f2} are functions of type ComponentFunction,{} in this case \spad{DF} \spad{->} \spad{DF}
ocreatePlot1Din3Dparametric`3`x`((DoubleFloat)->PT,Segment(DoubleFloat),NonNegativeInteger)->_$`dScene(PT)``\spad{createPlot1Din3Dparametric(pcfun,{} tRange,{} numPts)} create a line (1D subspace) in 3D space. This represents 1 dimension (line - possibly curved) in 3 dimensions In theory a line has no width but in that case we would not see it so we give it a width given by the material node that is applicable in this part of the scene graph PCFUN is a function from float to point: \spad{DF} \sp------------------------ad{->} \spad{PT}
ocreatePlot1Din3Dparametric`3`x`(ParametricSpaceCurve((DoubleFloat)->DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->_$`dScene(PT)``\spad{createPlot1Din3Dparametric(psc,{} tRange,{} numPts)} create a line (1D subspace) in 3D space. This represents 1 dimension (line - possibly curved) in 3 dimensions In theory a line has no width but in that case we would not see it so we give it a width given by the material node that is applicable in this part of the scene graph \spad{PSC} ParametricSpac------------------------eCurve(\spad{DF} \spad{->} \spad{DF}) is created with curve(\spad{f1},{} \spad{f2},{} \spad{f3}) where \spad{f1},{} \spad{f2} and \spad{f3} are functions of type ComponentFunction,{} in this case \spad{DF} \spad{->} \spad{DF}
ocreatePlot2Din3D`4`x`((DoubleFloat,DoubleFloat)->DoubleFloat,Segment(DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->_$`dScene(PT)``\spad{createPlot2Din3D(f,{} a..b,{} c..d)} returns a scene node which contains the graph of \spad{z} = \spad{f}(\spad{x},{} \spad{y}) as \spad{x} ranges from min(a,{} \spad{b}) to max(a,{} \spad{b}) and \spad{y} ranges from min(\spad{c},{} \spad{d}) to max(\spad{c},{} \spad{d}). create a surface (2D subspace) in 3D space The surface is approximated by polygo------------------------ns which are represented by in indexed face set (IFS) node
ocreatePlot2Din3D`4`x`((DoubleFloat,DoubleFloat)->PT,Segment(DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->_$`dScene(PT)``\spad{createPlot2Din3D(ptFun,{} uSeg,{} vSeg,{} numPts)} create a surface (2D subspace) in 3D space. The surface is approximated by polygons which are represented by in indexed face set (IFS) node
ocreatePlot2Din3Dparametric`4`x`((DoubleFloat,DoubleFloat)->PT,Segment(DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->_$`dScene(PT)``\spad{createPlot2Din3Dparametric(f,{} a..b,{} c..d,{} l)} returns a scene node which contains the graph of the parametric surface \spad{f}(\spad{u},{} \spad{v}) as \spad{u} ranges from min(a,{} \spad{b}) to max(a,{} \spad{b}) and \spad{v} ranges from min(\spad{c},{} \spad{d}) to max(\spad{c},{} \spad{d}). This creates a surface (2D subspace) in 3D space The------------------------ surface is approximated by polygons which are represented by in indexed face set (IFS) node
ocreatePlot2Din3Dparametric`4`x`(ParametricSurface((DoubleFloat,DoubleFloat)->DoubleFloat),Segment(DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->_$`dScene(PT)``\spad{createPlot2Din3Dparametric(surface(f,{} g,{} h),{} a..b,{} c..d,{} l)} returns a scene node which contains the graph of the parametric surface \spad{x} = \spad{f}(\spad{u},{} \spad{v}),{} \spad{y} = \spad{g}(\spad{u},{} \spad{v}),{} \spad{z} = \spad{h}(\spad{u},{} \spad{v}) as \spad{u} ranges from min(a,{} \spad{b}) to max(------------------------a,{} \spad{b}) and \spad{v} ranges from min(\spad{c},{} \spad{d}) to max(\spad{c},{} \spad{d}). This creates a surface (2D subspace) in 3D space The surface is approximated by polygons which are represented by in indexed face set (IFS) node
ocreateSceneArrow`5`x`(String,String,PT,Symbol,DoubleFloat)->_$`dScene(PT)``\spad{createSceneArrow(st,{} en,{} offset,{} mode,{} size)} constructs an arrow node,{} in \spad{n}-dimensional space,{} going from \spad{st} to \spad{en}. 'st' and 'en' are determined from a list of points from named points node. \spad{st} is the start of the arrow \spad{en} is the end of the arrow 'mode' and 'size' parameters determine the size of the arrowhead. \spad{mode} can have the following values: \indented{2}{"------------------------fixed"::Symbol \spad{--} fixed size line width given by 'size' parameter} \indented{2}{"proportional"::Symbol \spad{--} size as a proportion of the overall bounds} \indented{2}{"variable"::Symbol \spad{--} size as a proportion of the arrow length} So "proportional" would typically be used when drawing a graph (in graph theory) where it looks better if each arrow head is the same. "variable" would typically be used when drawing a force field where a bigger arrow head might-- i--nd--ic--at--e --a --st--ro--ng--er-- f--orce.
ocreateSceneArrow`6`x`(_$,_$,PT,Symbol,DoubleFloat,DoubleFloat)->_$`dScene(PT)``\spad{createSceneArrow(st,{} en,{} offset,{} mode,{} size,{} fontScale)} constructs an arrow node,{} in \spad{n}-dimensional space,{} going from \spad{st} to \spad{en}. 'st' and 'en' are nodes in the scene and the arrows will be drawn upto their boundary. \spad{st} is the node at the start of the arrow \spad{en} is the node at the end of the arrow 'mode' and 'size' parameters determine the \spad{size} of the arrowhea------------------------d. \spad{mode} can have the following values: \indented{2}{"fixed"::Symbol \spad{--} fixed \spad{size} line width given by 'size' parameter} \indented{2}{"proportional"::Symbol \spad{--} \spad{size} as a proportion of the overall bounds} \indented{2}{"variable"::Symbol \spad{--} \spad{size} as a proportion of the arrow length} So "proportional" would typically be used when drawing a graph (in graph theory) where it looks better if each arrow head is the same. "variable" w--ou--ld-- t--yp--ic--al--ly-- b--e --us--ed-- when drawing a force field where a bigger arrow head might indicate a stronger force. fontScale should be set to the full width of the diagram (not just the width of this node). If this is not known then choose an approximate value. This only affects text nodes,{} if \spad{st} or \spad{en},{} or its subnodes,{} do not contain a text node then its value is not significant.
ocreateSceneArrows`3`x`(List(List(PT)),Symbol,DoubleFloat)->_$`dScene(PT)``\spad{createSceneArrows(line,{} mode,{} size)} constructs an arrow node,{} this contains arrows (represented by a list of points) in \spad{n}-dimensional space. The space is implicit in the \spad{PT} and \spad{TR} parameters supplied when this Scene was created. 'mode' and 'size' parameters determine the size of the arrowhead. \spad{mode} can have the following values: \indented{2}{"fixed"::Symbol \spad{--} fixed size \sp------------------------ad{line} width given by 'size' parameter} \indented{2}{"proportional"::Symbol \spad{--} size as a proportion of the overall bounds} \indented{2}{"variable"::Symbol \spad{--} size as a proportion of the arrow length} So "proportional" would typically be used when drawing a graph (in graph theory) where it looks better if each arrow head is the same. "variable" would typically be used when drawing a force field where a bigger arrow head might indicate a stronger force.
ocreateSceneBox`1`x`(DoubleFloat)->_$`dScene(PT)``\spad{createSceneBox(size)} constructs an indexed face set node which is a 3D box of a given \spad{size}
ocreateSceneClip`1`x`(Record(mins:PT,maxs:PT))->_$`dScene(PT)``deprecated: this has been superseded by version with SBoundary(\spad{PT}) do not use,{} may be removed in the future.
ocreateSceneClip`1`x`(SBoundary(PT))->_$`dScene(PT)``\spad{createSceneClip(bb)} constructs a clip node,{} clips its sub nodes in the coordinate system in force at the clip node.
ocreateSceneDef`2`x`(String,_$)->_$`dScene(PT)``\spad{createSceneDef(nam,{} nde)} defines a point in the scenegraph so that it can be used elsewhere.
ocreateSceneGraph`4`x`(DirectedGraph(String),NonNegativeInteger,NonNegativeInteger,Boolean)->_$`dScene(PT)``\spad{createSceneGraph(g,{} x,{} y,{} dispArrowName)} creates a graph theory diagram
ocreateSceneGrid`1`x`(Record(mins:PT,maxs:PT))->_$`dScene(PT)``deprecated: this has been superseded by version with SBoundary(\spad{PT}) do not use,{} may be removed in the future.
ocreateSceneGrid`1`x`(SBoundary(PT))->_$`dScene(PT)``\spad{createSceneGrid(bb)} constructs a grid with narrow blue lines every 20 units wide blue lines every 100 units wide red lines every 200 units
ocreateSceneGrid`2`x`(DoubleFloat,Record(mins:PT,maxs:PT))->_$`dScene(PT)``deprecated: this has been superseded by version with SBoundary(\spad{PT}) do not use,{} may be removed in the future.
ocreateSceneGrid`2`x`(DoubleFloat,SBoundary(PT))->_$`dScene(PT)``\spad{createSceneGrid(stepSize,{} bb)} constructs a grid,{} consists of a group,{} under which are vertical and horizontal lines. The spacing between lines is given by step.
ocreateSceneGroup`0`x`()->_$`dScene(PT)``\spad{createSceneGroup()} constructs a group node,{} this node does not do anything itself but contains other nodes
ocreateSceneIFS`1`x`(SceneIFS(PT))->_$`dScene(PT)``\spad{createSceneIFS(in1)} constructs an indexed face set node,{} this defines a surface represented by a set of polygons in \spad{n}-dimensional space.
ocreateSceneIFS`2`x`(List(List(NonNegativeInteger)),List(PT))->_$`dScene(PT)``\spad{createSceneIFS(inx,{} pts)} constructs an indexed face set node,{} this defines a surface represented by a set of polygons in \spad{n}-dimensional space.
ocreateSceneLine`1`x`(List(PT))->_$`dScene(PT)``\spad{createSceneLine(line)} constructs a \spad{line} node,{} this contains a \spad{line} (represented by a list of points) in \spad{n}-dimensional space. The space is implicit in the \spad{PT} and \spad{TR} parameters supplied when this Scene was created.
ocreateSceneLine`3`x`(_$,_$,DoubleFloat)->_$`dScene(PT)``\spad{createSceneLine(st,{} en,{} fontScale)} constructs a line node,{} this contains a line,{} in \spad{n}-dimensions,{} from \spad{st} to \spad{en}. 'st' and 'en' are nodes in the scene and the line will be drawn upto their boundary. \spad{st} is the node at the start of the line \spad{en} is the node at the end of the line fontScale should be set to the full width of the diagram (not just the width of this node). If this is not known th------------------------en choose an approximate value. This only affects text nodes,{} if \spad{st} or \spad{en},{} or its subnodes,{} do not contain a text node then its value is not significant.
ocreateSceneLines`1`x`(List(List(PT)))->_$`dScene(PT)``\spad{createSceneLines(line)} constructs a \spad{line} node,{} this contains lines (represented by a list of points) in \spad{n}-dimensional space. The space is implicit in the \spad{PT} and \spad{TR} parameters supplied when this Scene was created.
ocreateSceneMaterial`1`x`(Record(lineWidth:DoubleFloat,lineCol:String,fillCol:String,matOpacity:DoubleFloat))->_$`dScene(PT)``\spad{createSceneMaterial(mat)} constructs a material node This sets the lineWidth,{} lineCol and fillCol for all nodes under this,{} unless overridden by another material node. That is the material parameters that apply to a given node are those of the closest material node above it in the hierarchy line width is expressed relative to the width of current boundary
ocreateSceneMaterial`3`x`(DoubleFloat,String,String)->_$`dScene(PT)``\spad{createSceneMaterial(lineW,{} lineC,{} fillC)} constructs a material node This sets the lineWidth,{} lineCol and fillCol for all nodes under this,{} unless overridden by another material node. That is the material parameters that apply to a given node are those of the closest material node above it in the hierarchy
ocreateSceneNamedPoints`1`x`(SceneNamedPoints(PT))->_$`dScene(PT)``\spad{createSceneNamedPoints(np)} constructs a named points node,{} this allows us to define a set of points which can be used multiple times in the scenegraph.
ocreateScenePattern`3`x`(Symbol,NonNegativeInteger,Record(mins:PT,maxs:PT))->_$`dScene(PT)``deprecated: this has been superseded by version with SBoundary(\spad{PT}) do not use,{} may be removed in the future.
ocreateScenePattern`3`x`(Symbol,NonNegativeInteger,SBoundary(PT))->_$`dScene(PT)``\spad{createScenePattern(ptype,{} step,{} bb)} creates a test pattern suitable for showing the effect of transforms. The pattern depends on \spad{ptype} parameter as follows: ptype="GRID"::Symbol : construct a set of horizontal and vertical lines in the current clip boundary and current material with a spacing between lines given by the \spad{step} parameter. ptype="SIERPINSKI"::Symbol: constructs a Sierpinski frac------------------------tal. \spad{step} parameter gives the level of subdivision. ptype="HOUSE"::Symbol: constructs a house shape.
ocreateSceneRoot`0`x`()->_$`dScene(PT)``\spad{createSceneRoot()} constructs the root node,{} all other nodes are contained in a tree structure under this node
ocreateSceneRoot`1`x`(Record(mins:PT,maxs:PT))->_$`dScene(PT)``deprecated: this has been superseded by version with SBoundary(\spad{PT}) do not use,{} may be removed in the future.
ocreateSceneRoot`1`x`(SBoundary(PT))->_$`dScene(PT)``\spad{createSceneRoot(bb)} constructs the root node,{} all other nodes are contained in a tree structure under this node
ocreateSceneRoot`4`x`(Integer,Integer,Integer,Integer)->_$`dScene(PT)``\spad{createSceneRoot(minx,{} miny,{} maxx,{} maxy)} constructs the root node,{} all other nodes are contained in a tree structure under this node
ocreateSceneRuler`3`x`(Symbol,PT,Record(mins:PT,maxs:PT))->_$`dScene(PT)``deprecated: this has been superseded by version with SBoundary(\spad{PT}) do not use,{} may be removed in the future.
ocreateSceneRuler`3`x`(Symbol,PT,SBoundary(PT))->_$`dScene(PT)``\spad{createSceneRuler(ptype,{} offset,{} bb)} creates a scale that can be used to provide numeric values for an axis: ptype= "HORIZONTAL"::Symbol : horizontal axis. ptype= "VERTICAL"::Symbol: vertical axis. ptype= "DEBTH"::Symbol: depth axis.
ocreateSceneShape`1`x`(Record(shptype:Symbol,centre:PT,size:PT,fill:Boolean))->_$`dScene(PT)``\spad{createSceneShape(shape)} constructs a \spad{shape} node,{} this contains a \spad{shape} such as a rectangle or an ellipse.
ocreateSceneShape`1`x`(SBoundary(PT))->_$`dScene(PT)``\spad{createSceneShape(shape)} constructs a \spad{shape} node from a boundary,{} this contains a \spad{shape} such as a rectangle or an ellipse.
ocreateSceneText`1`x`(Record(txt:String,siz:NonNegativeInteger,pos:PT,np:List(String)))->_$`dScene(PT)``\spad{createSceneText(text)} constructs a \spad{text} node,{} \spad{text} can be used for labelling anything such as graphs,{} axes and so on.
ocreateSceneText`3`x`(List(String),NonNegativeInteger,PT)->_$`dScene(PT)``\spad{createSceneText(str,{} sz,{} pz)} constructs a text node using information from named points node.
ocreateSceneText`3`x`(String,NonNegativeInteger,PT)->_$`dScene(PT)``\spad{createSceneText(str,{} sz,{} pz)} constructs a text node,{} text can be used for labelling anything such as graphs,{} axes and so on.
ocreateSceneTransform`1`x`(STransform(PT))->_$`dScene(PT)``\spad{createSceneTransform(tran)} constructs a transform node This transforms the points and vectors below this node If a given node has more than one transform node above it in the hierarchy then the transforms are compound
ocreateSceneUse`1`x`(String)->_$`dScene(PT)``\spad{createSceneUse(nam)} uses another point in the scenegraph.
ocreateWidth`1`x`(NonNegativeInteger)->NonNegativeInteger`cFiniteGraph(S)``\spad{createWidth(x)} can be used by domains which extend graph to help in creating coordinates for objects in a graph
ocreateWidth`1`x`(NonNegativeInteger)->NonNegativeInteger`xFiniteGraph&(A,S)``\spad{createWidth(x)} can be used by domains which extend graph to help in creating coordinates for objects in a graph
ocreateX`2`x`(NonNegativeInteger,NonNegativeInteger)->NonNegativeInteger`cFiniteGraph(S)``\spad{createX(x,{} n)} can be used by domains which extend graph to help in creating the \spad{x} coordinate for objects in a graph
ocreateX`2`x`(NonNegativeInteger,NonNegativeInteger)->NonNegativeInteger`xFiniteGraph&(A,S)``\spad{createX(x,{} n)} can be used by domains which extend graph to help in creating the \spad{x} coordinate for objects in a graph
ocreateY`2`x`(NonNegativeInteger,NonNegativeInteger)->NonNegativeInteger`cFiniteGraph(S)``\spad{createY(x,{} n)} can be used by domains which extend graph to help in creating the \spad{y} coordinate for objects in a graph
ocreateY`2`x`(NonNegativeInteger,NonNegativeInteger)->NonNegativeInteger`xFiniteGraph&(A,S)``\spad{createY(x,{} n)} can be used by domains which extend graph to help in creating the \spad{y} coordinate for objects in a graph
ocurveLoops`3`x`(List(PT),DoubleFloat,Integer)->List(List(PT))`dSceneIFS(PT)``\spad{curveLoops(pts1,{} r,{} nn)} generates ifs from line given by \spad{pts1}
ocycleClosed`2`x`(List(S),String)->_$`cFiniteGraph(S)``cycleClosed: (objs: List \spad{S},{} arrowName: String) constructs a graph with vertices (from objs) connected in a cycle. arrowName is a prefix for all arrow names,{} this will be followed by a number starting at 1 and incremented for each arrow
ocycleOpen`2`x`(List(S),String)->_$`cFiniteGraph(S)``\spad{cycleOpen(objs,{} arrowName)} constructs a graph with vertices (from \spad{objs}) connected in a cycle but with one gap. The last vertex in the sequence loops back to itself so all vertices have one outgoing arrow. arrowName is a prefix for all arrow names,{} this will be followed by a number starting at 1 and incremented for each arrow
odashLine`0`x`()->OutputForm`cInternalMessageLevel``
odashLine`0`x`()->OutputForm`xInternalMessageLevel&(S)``
odeepDiagramSvg`3`x`(String,A,Boolean)->Void`xFiniteGraph&(A,S)``
odeepDiagramSvg`3`x`(String,_$,Boolean)->Void`cFiniteGraph(S)``
odiagramHeight`1`x`(A)->NonNegativeInteger`xFiniteGraph&(A,S)``
odiagramHeight`1`x`(_$)->NonNegativeInteger`cFiniteGraph(S)``\spad{diagramHeight(s)} returns the height of the diagram that will be generated by diagramSvg. This is the maximum posY of all vertices in graph \spad{s}
odiagramSvgLine`3`x`(String,_$,Boolean)->Void`dUndirectedGraph(S)``diagramSvg(fileName,{} \spad{n},{} dispArrowName) creates an \spad{SVG} diagram fileName: String is the name of the \spad{SVG} file that will be created \spad{n:} \% is the graph that will be written dispArrowName: Boolean is \spad{true} to include the name of each arrow
odiagramSvg`3`x`(String,A,Boolean)->Void`xFiniteGraph&(A,S)``
odiagramSvg`3`x`(String,_$,Boolean)->Void`cFiniteGraph(S)``\spad{diagramSvg(fileName,{} n,{} dispArrowName)} creates an \spad{SVG} diagram fileName: String is the name of the \spad{SVG} file that will be created \spad{n:} \% is the graph that will be written dispArrowName: Boolean is \spad{true} to include the name of each arrow
odiagramWidth`1`x`(A)->NonNegativeInteger`xFiniteGraph&(A,S)``
odiagramWidth`1`x`(_$)->NonNegativeInteger`cFiniteGraph(S)``\spad{diagramWidth(s)} returns the width of the diagram that will be generated by diagramSvg. This is the maximum posX of all vertices in graph \spad{s}
odiagramsSvgLine`3`x`(String,List(_$),Boolean)->Void`dUndirectedGraph(S)``
odimension`1`x`(_$)->PositiveInteger`cSPointCategory``\spad{dimension(p)} returns the number of dimensions that make up the point category \spad{p}.
odirectedGraph`1`x`(List(Permutation(S)))->_$`dDirectedGraph(S)``\spad{directedGraph(perms)} constructs graph from a list of permutations: \spad{perms}.
odirectedGraph`1`x`(List(Record(value:S,posX:NonNegativeInteger,posY:NonNegativeInteger)))->_$`dDirectedGraph(S)``\spad{directedGraph(ob)} is a constructor for graph with given objects \spad{ob},{} more objects and arrows can be added later if required.
odirectedGraph`1`x`(List(S))->_$`dDirectedGraph(S)``\spad{directedGraph(ob)} is a constructor for graph with given list of object names and no arrows. Use this version of the constructor if you don\spad{'t} want to create specific \spad{x},{} \spad{y} coordinates. more objects and arrows can be added later if required.
odirectedGraph`2`x`(List(Record(value:S,posX:NonNegativeInteger,posY:NonNegativeInteger)),List(Record(name:String,arrType:NonNegativeInteger,fromOb:NonNegativeInteger,toOb:NonNegativeInteger,xOffset:Integer,yOffset:Integer,map:List(NonNegativeInteger))))->_$`dDirectedGraph(S)``\spad{directedGraph(ob,{} ar)} construcs graph with objects \spad{ob} and arrows ar,{} more objects and arrows can be added later if required.
odirectedGraph`2`x`(List(S),List(List(NonNegativeInteger)))->_$`dDirectedGraph(S)``\spad{directedGraph(ob,{} am)} construcs graph with objects \spad{ob} and adjacency matrix am.
odistanceMatrix`1`x`(A)->Matrix(Integer)`xFiniteGraph&(A,S)``
odistanceMatrix`1`x`(_$)->Matrix(Integer)`cFiniteGraph(S)``\spad{distanceMatrix(s)} gives matrix of distances between vertices. Element a_{\spad{i},{} \spad{j}} is the distance from \spad{i} to \spad{j}. Distance matrices are related to adjacency matrices,{} with the differences that: a) the latter only provides the information which vertices are connected \indented{3}{but does not tell about costs or distances between the vertices} \spad{b}) adjacency matrix only tells us about directly connect------ed \indented{3}{vertices while distance matrix also considers indirect connections.}
odistanceSquared`2`x`(_$,_$)->DoubleFloat`cSPointCategory``\spad{distanceSquared(p1,{} p2)} returns the distance between the points \spad{p1} and \spad{p2}. There are 2 metrics associated with any SPointCategory the underlying space and the space that it is embedded in this is the distance in the underlying space.
odistanceWeighted`3`x`(_$,NonNegativeInteger,NonNegativeInteger)->Union(W,"disjoint")`dWeightedGraph(S,W)``the shortest distance between 'a' and \spad{'b'} in terms of weight.
odistance`2`x`(S,S)->DoubleFloat`xSPointCategory&(S)``
odistance`2`x`(_$,_$)->DoubleFloat`cSPointCategory``\spad{distance(p1,{} p2)} returns the distance between the points \spad{p1} is the first point. \spad{p2} is the second point. There are 2 metrics associated with any SPointCategory the underlying space and the space that it is embedded in this is the distance in the underlying space.
odistance`3`x`(A,NonNegativeInteger,NonNegativeInteger)->Integer`xFiniteGraph&(A,S)``
odistance`3`x`(_$,NonNegativeInteger,NonNegativeInteger)->Integer`cFiniteGraph(S)``\spad{distance(s,{} a,{} b)} gives the shortest distance between nodes 'a' and \spad{'b'} as a number of hops. 0 if 'a' = \spad{'b'},{} \spad{-1} if it is not possible to go from 'a' to \spad{'b'}
odottedLine`0`x`()->OutputForm`cInternalMessageLevel``
odottedLine`0`x`()->OutputForm`xInternalMessageLevel&(S)``
oellipseBoundary`2`x`(PT,PT)->_$`dSBoundary(PT)``\spad{ellipseBoundary(c1,{} c2)} constructs an ellipse boundary \spad{n}-dimensional axis-aligned ellipoid with given parameters \spad{c1:} \spad{PT} holds centre point \spad{c2:} \spad{PT} holds extent (radius for each coordinate)
oempty?`1`x`(_$)->Boolean`dXmlElement``\spad{empty?(el)} returns \spad{true} is this element does not contain anything
oentries`1`x`(_$)->List(NonNegativeInteger)`dLoop``\spad{entries(lp)} returns list of indexes that make this loop
oequalLine`0`x`()->OutputForm`cInternalMessageLevel``
oequalLine`0`x`()->OutputForm`xInternalMessageLevel&(S)``
oextendToPoint`2`x`(_$,PT)->_$`dSBoundary(PT)``\spad{extendToPoint(n,{} p)} creates a boundary that is the union \indented{2}{of a boundary and a point.} \spad{n} is the boundary \spad{p} is the point
oextendedCoords`1`x`(_$)->List(DoubleFloat)`cSPointCategory``\spad{extendedCoords(pt)} returns extended coordinates as a list.
ofindNode`2`x`(_$,String)->Scene(PT)`dSceneNamedPoints(PT)``\spad{findNode(n,{} ptName)} finds a scene node
ofindPoint`2`x`(_$,String)->PT`dSceneNamedPoints(PT)``\spad{findPoint(n,{} ptName)} find the point associated with a given string.
oflatten`1`x`(DirectedGraph(_$))->_$`cFiniteGraph(S)``\spad{flatten(n)} takes a second order graph,{} that is a graph whose elements are themselves graphs and create a first order graph whose vertices are the vertices of the inner graphs.
ofunctionGraph`1`x`(List(Permutation(S)))->_$`dFunctionGraph(S)``construct graph from a list of permutations.
ofunctionGraph`1`x`(List(Record(value:S,posX:NonNegativeInteger,posY:NonNegativeInteger,next:NonNegativeInteger,map:List(NonNegativeInteger))))->_$`dFunctionGraph(S)``constructor for graph with given objects more objects and arrows can be added later if required.
ofunctionGraph`1`x`(List(S))->_$`dFunctionGraph(S)``constructor for graph with given list of object names. Use this version of the constructor if you don\spad{'t} intend to create diagrams and therefore don\spad{'t} care about \spad{x},{} \spad{y} coordinates. more objects and arrows can be added later if required.
ofunctionGraph`2`x`(List(Record(value:S,posX:NonNegativeInteger,posY:NonNegativeInteger)),List(Record(name:String,arrType:NonNegativeInteger,fromOb:NonNegativeInteger,toOb:NonNegativeInteger,xOffset:Integer,yOffset:Integer,map:List(NonNegativeInteger))))->_$`dFunctionGraph(S)``constructor for graph with given objects and arrows more objects and arrows can be added later if required.
ogetArrowIndex`3`x`(A,NonNegativeInteger,NonNegativeInteger)->NonNegativeInteger`xFiniteGraph&(A,S)``
ogetArrowIndex`3`x`(_$,NonNegativeInteger,NonNegativeInteger)->NonNegativeInteger`cFiniteGraph(S)``\spad{getArrowIndex(s,{} a,{} b)} retrieves arrow index of the arrow form a to \spad{b}
ogetArrows`1`x`(_$)->List(Record(name:String,arrType:NonNegativeInteger,fromOb:NonNegativeInteger,toOb:NonNegativeInteger,xOffset:Integer,yOffset:Integer,map:List(NonNegativeInteger)))`cFiniteGraph(S)``\spad{getArrows(s)} returns a list of all the arrows (or edges)
ogetCentre`1`x`(_$)->PT`dSBoundary(PT)``\spad{getCentre(n)} returns centre coordinate of the boundary. \spad{n:} \% is the boundary
ogetMax`1`x`(_$)->PT`dSBoundary(PT)``\spad{getMax(n)} returns maximum coordinate of the boundary. \spad{n} is the boundary
ogetMin`1`x`(_$)->PT`dSBoundary(PT)``\spad{getMin(n)} returns minimum coordinate of the boundary. \spad{n} is the boundary
ogetNames`1`x`(_$)->List(String)`dSceneNamedPoints(PT)``\spad{getNames(n)} returns a list of names for this node
ogetVertexIndex`2`x`(A,S)->NonNegativeInteger`xFiniteGraph&(A,S)``
ogetVertexIndex`2`x`(_$,S)->NonNegativeInteger`cFiniteGraph(S)``\spad{getVertexIndex(s,{} v)} retrieves vertex index of the vertex \spad{v}
ogetVertices`1`x`(_$)->List(Record(value:S,posX:NonNegativeInteger,posY:NonNegativeInteger))`cFiniteGraph(S)``\spad{getVertices(s)} returns a list of all the vertices (or objects) of the graph \spad{s}.
ohash`1`x`(A)->SingleInteger`xFiniteGraph&(A,S)``
oidentity`0`x`()->_$`dSTransform(PT)``\spad{identity()} returns the identity element which is do nothing transform
oinBounds?`3`x`(_$,_$,_$)->Boolean`cSPointCategory``\spad{inBounds?(pt,{} mns,{} mxs)} returns \spad{true} if \spad{pt} is inside bounding box where bounding box is specified by min and max.
oinDegree`2`x`(A,NonNegativeInteger)->NonNegativeInteger`xFiniteGraph&(A,S)``
oinDegree`2`x`(_$,NonNegativeInteger)->NonNegativeInteger`cFiniteGraph(S)``\spad{inDegree(s,{} a)} gives the number of arrows leading in to node 'a' in graph \spad{'s'}
oincidenceMatrix`1`x`(A)->Matrix(Integer)`xFiniteGraph&(A,S)``
oincidenceMatrix`1`x`(_$)->Matrix(Integer)`cFiniteGraph(S)``\spad{incidenceMatrix(s)} represents graph \spad{s} by a matrix of size \spad{|V|} by |E| where: V=number of vertices E=number of edges entry [vertex,{} arrow] = arrow endpoint data (undirected case case: 1 - incident,{} 0 - not incident,{} directed case: \spad{-1} - start,{} 1 - end,{} 0 - not incident).
oindexes`1`x`(_$)->List(List(NonNegativeInteger))`dSceneIFS(PT)``\spad{indexes(me)} returns indexes into pointList(\spad{me})
oinitial`0`x`()->_$`cFiniteGraph(S)``\spad{initial constructs} a graph without vertices or edges
ointersection`1`x`(List(_$))->_$`dSBoundary(PT)``\spad{intersection(x)} constructs a compound boundary from the intersection of \spad{x} \spad{x:} List \% is supplied list of boundaries to form intersection.
oisAcyclic?`1`x`(A)->Boolean`xFiniteGraph&(A,S)``
oisAcyclic?`1`x`(_$)->Boolean`cFiniteGraph(S)``\spad{isAcyclic?(s)} returns \spad{true} if there are no loops
oisBox?`1`x`(_$)->Boolean`dSBoundary(PT)``\spad{isBox?(n)} returns \spad{true} if this is a rectangular boundary.
oisDirectSuccessor?`3`x`(A,NonNegativeInteger,NonNegativeInteger)->Boolean`xFiniteGraph&(A,S)``
oisDirectSuccessor?`3`x`(_$,NonNegativeInteger,NonNegativeInteger)->Boolean`cFiniteGraph(S)``\spad{isDirectSuccessor?(s,{} a,{} b)} is \spad{true} if \spad{'b'} is a direct successor of 'a' that is,{} if there is a direct arrow from 'a' to \spad{'b'}
oisDirected?`0`x`()->Boolean`cFiniteGraph(S)``isDirected? is \spad{true} iff \% is domain consisting of directed graphs,{} \spad{false} for undirected graphs.
oisDirected?`0`x`()->Boolean`xFiniteGraph&(A,S)``isDirected? is \spad{true} iff \% is domain consisting of directed graphs,{} \spad{false} for undirected graphs.
oisEllipse?`1`x`(_$)->Boolean`dSBoundary(PT)``\spad{isEllipse?(n)} returns \spad{true} if this is a ellipsoid boundary.
oisFixPoint?`2`x`(A,NonNegativeInteger)->Boolean`xFiniteGraph&(A,S)``
oisFixPoint?`2`x`(_$,NonNegativeInteger)->Boolean`cFiniteGraph(S)``\spad{isFixPoint?(s,{} a)} is \spad{true} if 'a' has an arrow to itself
oisFunctional?`1`x`(A)->Boolean`xFiniteGraph&(A,S)``
oisFunctional?`1`x`(_$)->Boolean`cFiniteGraph(S)``\spad{isFunctional?(s)} returns \spad{true} if \spad{s} is a functional graph,{} that is a directed graph in which each vertex has a single outgoing arrow.
oisGreaterThan?`3`x`(A,NonNegativeInteger,NonNegativeInteger)->Boolean`xFiniteGraph&(A,S)``
oisGreaterThan?`3`x`(_$,NonNegativeInteger,NonNegativeInteger)->Boolean`cFiniteGraph(S)``isGreaterThan?((\spad{s},{} a,{} \spad{b}) is \spad{true} if we can get from vertex 'a' to \spad{'b'} through a sequence of arrows but we can\spad{'t} go in the opposite direction from \spad{'b'} to 'a'
oisNodeBranch?`1`x`(_$)->Boolean`dSceneNamedPoints(PT)``\spad{isNodeBranch?(n)} returns \spad{true} if this is a branch.
oisNodeLeaf?`1`x`(_$)->Boolean`dSceneNamedPoints(PT)``\spad{isNodeLeaf?(n)} returns \spad{true} if this is a leaf which holds Scene nodes.
oisNull?`1`x`(_$)->Boolean`dSBoundary(PT)``\spad{isNull?(n)} returns \spad{true} if this is a null boundary,{} that is no boundary
oisPoint?`1`x`(_$)->Boolean`cSPointCategory``\spad{isPoint?(p)} returns \spad{true} if this represents a point as opposed to a vector.
oisPointLeaf?`1`x`(_$)->Boolean`dSceneNamedPoints(PT)``\spad{isPointLeaf?(n)} returns \spad{true} if this is a \spad{pt} node,{} that is,{} if this node contains points
oisVector?`1`x`(_$)->Boolean`cSPointCategory``\spad{isVector? returns} \spad{true} if this represents a vector as opposed to a point.
okgraph`2`x`(List(S),String)->_$`cFiniteGraph(S)``\spad{kgraph(objs,{} arrowName)} constructs a graph with vertices (from \spad{objs}) and fully connected arrows,{} that is,{} each object has an arrow to every other object except itself. arrowName is a prefix for all arrow names,{} this will be followed by a number starting at 1 and incremented for each arrow
olaplacianMatrix`1`x`(A)->Matrix(Integer)`xFiniteGraph&(A,S)``
olaplacianMatrix`1`x`(_$)->Matrix(Integer)`cFiniteGraph(S)``\spad{laplacianMatrix(s)} returns matrix also known as "Kirchhoff matrix" or "Admittance matrix" where: entry [\spad{i},{} \spad{j}] = inDegree(\spad{vi}) if \spad{i} = \spad{j} (number of incoming links) \spad{-1} if \spad{i} not = \spad{j} and \spad{vi} is adjacent to \spad{vj} 0 otherwise Alternatively this is defined as \spad{D} - A,{} where \spad{D} is the diagonal degree matrix. It contains both adjacency information and degree in------formation. There are other,{} similar matrices,{} that are also called "Laplacian matrices" of a graph.
olatex`1`x`(A)->String`xFiniteGraph&(A,S)``
olimit`2`x`(_$,NonNegativeInteger)->Loop`dFunctionGraph(S)``apply 'function' represented by this graph to 'a' repeatedly until we reach a loop which is returned as a sequence of vertex indexes.
olimit`3`x`(_$,NonNegativeInteger,NonNegativeInteger)->Loop`dMultifunctionGraph(S)``apply 'function' represented by this graph to 'a' repeatedly until we reach a loop which is returned as a sequence of vertex indexes.
olineIntersect`2`x`(_$,PT)->PT`dSBoundary(PT)``\spad{lineIntersect(n,{} p)} returns the point where a line,{} from the centre of the boundary to the point \spad{p},{} intersects with the boundary. \spad{n:} \% is the boundary \spad{p:} \spad{PT} is the point at the end of the line (outside boundary)
oline`1`x`(String)->OutputForm`cInternalMessageLevel``\spad{line(c: String)} constructs a line,{} \spadignore{i.e.} 72 copies of String \spad{c}.
oline`1`x`(String)->OutputForm`xInternalMessageLevel&(S)``\spad{line(c: String)} constructs a line,{} \spadignore{i.e.} 72 copies of String \spad{c}.
olink`2`x`(_$,_$)->List(PT)`dSBoundary(PT)``\spad{link(m,{} n)} returns a line which is the shortest distance between the two boundaries. The line is represented by its two endpoints. \spad{m:} \% is the first boundary to be linked \spad{n:} \% is the second boundary to be linked
oloop`1`x`(List(NonNegativeInteger))->_$`dLoop``\spad{loop(\spad{li})} constructs loop from list of indexes \spad{li}
oloopsArrows`1`x`(A)->List(Loop)`xFiniteGraph&(A,S)``
oloopsArrows`1`x`(_$)->List(Loop)`cFiniteGraph(S)``\spad{loopsArrows(s)} returns a list of loops for this graph in this case the loop is represented by the indexes of the sequence of nodes passed through. to-do: it would be better to use a more efficient algorithm,{} currently the code calls spanningForestArrow and traverses the result for loops,{} it might be more efficient to use Floyds algorithm.
oloopsAtNode`2`x`(A,NonNegativeInteger)->List(Loop)`xFiniteGraph&(A,S)``
oloopsAtNode`2`x`(_$,NonNegativeInteger)->List(Loop)`cFiniteGraph(S)``\spad{loopsAtNode(s,{} a)} returns a list of loops for this graph that pass through vertex index 'a'
oloopsNodes`1`x`(A)->List(Loop)`xFiniteGraph&(A,S)``
oloopsNodes`1`x`(_$)->List(Loop)`cFiniteGraph(S)``\spad{loopsNodes(s)} returns a list of loops for this graph in this case the loop is represented by the indexes of the sequence of nodes passed through.
olooseEquals`2`x`(A,A)->Boolean`xFiniteGraph&(A,S)``
olooseEquals`2`x`(_$,_$)->Boolean`cFiniteGraph(S)``\spad{looseEquals(x,{} y)} is \spad{true} if \spad{x} 'equals' \spad{y} this is a looser version of equality test but is not as general as isomorphism. it only requires the same number of vertices but does not require the objects themselves being equal. the arrows must be the same,{} that is it may return \spad{false} if the order of vertices is changed so this is not isomorphism test.
omapContra`5`x`(_$,List(NonNegativeInteger),List(S),Integer,Integer)->_$`cFiniteGraph(S)``\spad{mapContra(s,{} m,{} newOb,{} offsetX,{} offsetY)} is similar to map function but reverses the directions of the arrows
omap`5`x`(_$,List(NonNegativeInteger),List(S),Integer,Integer)->_$`cFiniteGraph(S)``\spad{map(s,{} m,{} newOb,{} offsetX,{} offsetY)} creates a new graph by mapping from this one \spad{newOb} should contain the new list of vertices. \spad{m} should contain a NNI value for each vertex,{} this is the new index into \spad{newOb}. It is allowed that \spad{newOb} may contain less objects than \spad{s} (for surjective mapping) or more objects than \spad{s} (for injective mapping)
omax`1`x`(A)->NonNegativeInteger`xFiniteGraph&(A,S)``
omax`1`x`(_$)->NonNegativeInteger`cFiniteGraph(S)``\spad{max(s)} returns index of the vertex which can be reached from all other vertices. Gives 0 if no such node exists or if it is not unique,{} if there is a loop for instance.
omax`2`x`(A,List(NonNegativeInteger))->NonNegativeInteger`xFiniteGraph&(A,S)``
omax`2`x`(_$,List(NonNegativeInteger))->NonNegativeInteger`cFiniteGraph(S)``\spad{max(s,{} sub)} returns index of the vertex which can be reached from a given subset of the vertices. Gives 0 if no such node exists or if it is not unique,{} if there is a loop for instance.
omax`2`x`(_$,_$)->_$`cSPointCategory``\spad{max(a,{} b)} returns a point whose value in each dimension is the maximum. So if a has the largest \spad{x} value and \spad{b} has the largest \spad{y} value then the result will combine these. This is useful for constructing boundary boxes around sets of points.
omerge`2`x`(_$,_$)->_$`cFiniteGraph(S)``\spad{merge(a,{} b)} returns sum : union (not necessarily disjoint) of nodes with arrows merged in from appropriate input,{} if arrow exists from both inputs then it will be duplicated.
omessageLevel?`0`x`()->NonNegativeInteger`cInternalMessageLevel``messageLevel() returns 0,{} 1,{} 2 or 3 as message levels
omessageLevel?`0`x`()->NonNegativeInteger`xInternalMessageLevel&(S)``messageLevel() returns 0,{} 1,{} 2 or 3 as message levels
omessageLevelPointer`1`x`(NonNegativeInteger)->Boolean`cInternalMessageLevel``\spad{messageLevelPointer(i)} returns the value to which the \spad{i}-th pointer points.
omessageLevelPointer`1`x`(NonNegativeInteger)->Boolean`xInternalMessageLevel&(S)``\spad{messageLevelPointer(i)} returns the value to which the \spad{i}-th pointer points.
omessageLevelPointers`0`x`()->List(Boolean)`cInternalMessageLevel``\spad{messageLevelPointers returns} a list of all values to which the pointers point.
omessageLevelPointers`0`x`()->List(Boolean)`xInternalMessageLevel&(S)``\spad{messageLevelPointers returns} a list of all values to which the pointers point.
omin`1`x`(A)->NonNegativeInteger`xFiniteGraph&(A,S)``
omin`1`x`(_$)->NonNegativeInteger`cFiniteGraph(S)``\spad{min(s)} returns index of the vertex which can reach to all other vertices. Gives 0 if no such node exists or if it is not unique,{} if there is a loop for instance.
omin`2`x`(A,List(NonNegativeInteger))->NonNegativeInteger`xFiniteGraph&(A,S)``
omin`2`x`(_$,List(NonNegativeInteger))->NonNegativeInteger`cFiniteGraph(S)``\spad{min(s,{} sub)} returns index of the vertex which can reach to a given subset of the vertices. Gives 0 if no such node exists or if it is not unique,{} if there is a loop for instance.
omin`2`x`(_$,_$)->_$`cSPointCategory``\spad{min(a,{} b)} returns a point whose value in each dimension is the minimum. So if a has the smallest \spad{x} value and \spad{b} has the smallest \spad{y} value then the result will combine these. This is useful for constructing boundary boxes around sets of points.
omultifunctionGraph`1`x`(List(Permutation(S)))->_$`dMultifunctionGraph(S)``construct graph from a list of permutations.
omultifunctionGraph`1`x`(List(Record(value:S,posX:NonNegativeInteger,posY:NonNegativeInteger,next:List(NonNegativeInteger),map:List(List(NonNegativeInteger)))))->_$`dMultifunctionGraph(S)``constructor for graph with given objects more objects and arrows can be added later if required.
omultifunctionGraph`1`x`(List(S))->_$`dMultifunctionGraph(S)``constructor for graph with given list of object names. Use this version of the constructor if you don\spad{'t} intend to create diagrams and therefore don\spad{'t} care about \spad{x},{} \spad{y} coordinates. more objects and arrows can be added later if required.
omultifunctionGraph`2`x`(List(Record(value:S,posX:NonNegativeInteger,posY:NonNegativeInteger)),List(Record(name:String,arrType:NonNegativeInteger,fromOb:NonNegativeInteger,toOb:NonNegativeInteger,xOffset:Integer,yOffset:Integer,map:List(NonNegativeInteger))))->_$`dMultifunctionGraph(S)``constructor for graph with given objects and arrows more objects and arrows can be added later if required.
omultifunctionGraph`2`x`(List(S),List(List(NonNegativeInteger)))->_$`dMultifunctionGraph(S)``constructor for graph with given objects and adjacency matrix.
onamedBranch`2`x`(List(_$),List(String))->_$`dSceneNamedPoints(PT)``\spad{namedBranch(chin,{} nmin)} constructs a branch in the tree structure
onamedPoints`2`x`(List(PT),List(String))->_$`dSceneNamedPoints(PT)``\spad{namedPoints(ptin,{} nmin)} constructs a list of named points.
onamedPoints`2`x`(List(Scene(PT)),List(String))->_$`dSceneNamedPoints(PT)``\spad{namedPoints(scin,{} nmin)} constructs a list of named nodes.
onodeFromArrow`2`x`(A,NonNegativeInteger)->List(NonNegativeInteger)`xFiniteGraph&(A,S)``
onodeFromArrow`2`x`(_$,NonNegativeInteger)->List(NonNegativeInteger)`cFiniteGraph(S)``\spad{nodeFromArrow(s,{} a)} returns index of all nodes with a direct arrow leading in to arrow 'a' in graph \spad{'s'}
onodeFromNode`2`x`(A,NonNegativeInteger)->List(NonNegativeInteger)`xFiniteGraph&(A,S)``
onodeFromNode`2`x`(_$,NonNegativeInteger)->List(NonNegativeInteger)`cFiniteGraph(S)``\spad{nodeFromNode(s,{} a)} gives list of all nodes with a direct arrow leading in to node 'a' in graph \spad{'s'}
onodeToArrow`2`x`(A,NonNegativeInteger)->List(NonNegativeInteger)`xFiniteGraph&(A,S)``
onodeToArrow`2`x`(_$,NonNegativeInteger)->List(NonNegativeInteger)`cFiniteGraph(S)``\spad{nodeToArrow(s,{} a)} returns index of all nodes with a direct arrow leading out of arrow 'a' in graph \spad{'s'}
onodeToNode`2`x`(A,NonNegativeInteger)->List(NonNegativeInteger)`xFiniteGraph&(A,S)``
onodeToNode`2`x`(_$,NonNegativeInteger)->List(NonNegativeInteger)`cFiniteGraph(S)``\spad{nodeToNode(s,{} a)} gives list of all nodes with a direct arrow leading out of node 'a' in graph \spad{'s'}
onormalisePoint`1`x`(_$)->_$`dSConformal(n)``normalalised point has scalar value of one,{} if this is not the case then scale values
onullBoundary`0`x`()->_$`dSBoundary(PT)``\spad{nullBoundary()} constructs a null boundary,{} for example,{} when the boundary of a material node is requested.
ooutDegree`2`x`(A,NonNegativeInteger)->NonNegativeInteger`xFiniteGraph&(A,S)``
ooutDegree`2`x`(_$,NonNegativeInteger)->NonNegativeInteger`cFiniteGraph(S)``\spad{outDegree(s,{} a)} gives the number of arrows leading out of node 'a' in graph \spad{'s'}
ooutputVRML`2`x`(_$,TextFile)->Void`dXmlAttribute``\spad{outputVRML(rp,{} f1)} writes the attribute as \spad{VRML2}. \spad{VRML2} is not \spad{xml} but it has the same semantics and node names as \spad{X3D} but a different syntax so it makes sense to create an \spad{XML} structure and then format the output differently.
ooutputVRML`2`x`(_$,TextFile)->Void`dXmlElement``\spad{outputVRML(rp,{} f1)} writes the element as \spad{VRML2}. \spad{VRML2} is not \spad{xml} but it has the same semantics and node names as \spad{X3D} but a different syntax so it makes sense to create an \spad{XML} structure and then format the output differently.
oparallel`2`x`(_$,_$)->DoubleFloat`cSPointCategory``\spad{parallel(x,{} y)} returns the length of the parallel component of two vectors. In the case of Euclidean space this is the dot product of two vectors. We use this function to test the colinearity
operpendicular`2`x`(_$,_$)->_$`cSPointCategory``\spad{perpendicular(x,{} y)} returns a vector perpendicular to the two vectors in the case of 3D Euclidean space this is the cross the product of two vectors. We use this function to compute orthogonal
opointList`1`x`(_$)->List(PT)`dSceneIFS(PT)``\spad{pointList(me)} returns points at vertices of this mesh.
orectangleGraphs`3`x`(Matrix(Integer),List(List(Integer)),NonNegativeInteger)->UndirectedGraph(Integer)`dVelocitiesToGraph(K)``addRectangle(\spad{vP},{} \spad{lRec},{} \spad{nc}) \indented{2}{constructs one graph containing all rectangles in an array with \spad{nc} columns} \indented{2}{\spad{vG} is a velocity picture,{} \spad{lRec} a list of rectangles.}
orectangleGraphs`4`x`(Matrix(Integer),List(List(Integer)),NonNegativeInteger,NonNegativeInteger)->UndirectedGraph(Integer)`dVelocitiesToGraph(K)``addRectangle(\spad{vP},{} \spad{lRec},{} \spad{nc},{} dist) \indented{2}{constructs one graph containing all rectangles in an array with \spad{nc} columns} \indented{2}{\spad{vG} is a velocity picture,{} \spad{lRec} a list of rectangles and dist is the } \indented{2}{space in points between two rectangles.}
oremoveChild!`2`x`(_$,_$)->Void`dScene(PT)``\spad{removeChild!(n,{} c)} removes the specified child node \spad{'c'} below node \spad{'n'}
orouteArrowWeight`2`x`(_$,List(NonNegativeInteger))->W`dWeightedGraph(S,W)``the cumulative weight of a given route. The route is given in terms of a sequence of arrow indexes.
orouteArrows`3`x`(A,NonNegativeInteger,NonNegativeInteger)->List(NonNegativeInteger)`xFiniteGraph&(A,S)``
orouteArrows`3`x`(_$,NonNegativeInteger,NonNegativeInteger)->List(NonNegativeInteger)`cFiniteGraph(S)``\spad{routeArrows(s,{} a,{} b)} gives the shortest route between nodes 'a' and \spad{'b'} as a sequence of arrow indexes. [] if 'a' = \spad{'b'} [0] if it is not possible to go from 'a' to \spad{'b'}
orouteNodeWeight`2`x`(_$,List(NonNegativeInteger))->W`dWeightedGraph(S,W)``the cumulative weight of a given route. The route is given in terms of a sequence of node indexes.
orouteNodes`3`x`(A,NonNegativeInteger,NonNegativeInteger)->List(NonNegativeInteger)`xFiniteGraph&(A,S)``
orouteNodes`3`x`(_$,NonNegativeInteger,NonNegativeInteger)->List(NonNegativeInteger)`cFiniteGraph(S)``\spad{routeNodes(s,{} a,{} b)} gives the shortest route between nodes 'a' and \spad{'b'} as a sequence of node indexes. [a] if 'a' = \spad{'b'} [] if it is not possible to go from 'a' to \spad{'b'}
oscreenCoordX`1`x`(_$)->DoubleFloat`cSPointCategory``\spad{screenCoordX(pt)} returns the \spad{'x'}(left to right) screen coordinate.
oscreenCoordY`1`x`(_$)->DoubleFloat`cSPointCategory``\spad{screenCoordY(pt)} returns the \spad{'y'}(bottom to top) screen coordinate.
oscreenCoordZ`1`x`(_$)->DoubleFloat`cSPointCategory``\spad{screenCoordZ(pt)} returns the \spad{'z'}(out from screen) screen coordinate.
oscreenCoords`1`x`(_$)->List(DoubleFloat)`cSPointCategory``\spad{screenCoords(pt)} returns screen coordinates as a list.
osetMessageLevel`1`x`(NonNegativeInteger)->NonNegativeInteger`cInternalMessageLevel``\spad{setMessageLevel(l)} depending on \spad{l=0} (no),{} \spad{l=1} (minimal),{} \spad{l=2} (more),{} \spad{l=3} all internal messages and informations are given.
osetMessageLevel`1`x`(NonNegativeInteger)->NonNegativeInteger`xInternalMessageLevel&(S)``\spad{setMessageLevel(l)} depending on \spad{l=0} (no),{} \spad{l=1} (minimal),{} \spad{l=2} (more),{} \spad{l=3} all internal messages and informations are given.
osetTransform!`2`x`(_$,STransform(PT))->Void`dScene(PT)``\spad{setTransform!(n,{} tran)} changes the transform without altering the scene hierarchy
osierpinskiDivide`2`x`(_$,NonNegativeInteger)->_$`dSceneIFS(PT)``\spad{sierpinskiDivide(me,{} level)} for each edge of each face calculate a new point in the centre of the edge,{} then build a new set of faces which include the new points.
osingleFace`1`x`(List(PT))->_$`dSceneIFS(PT)``\spad{singleFace(ptin)} constructs a ifs representation of a face from an array of points
osipnt`2`x`(Integer,Integer)->S`xSPointCategory&(S)``
osipnt`2`x`(Integer,Integer)->_$`cSPointCategory``\spad{sipnt(a,{} b)} constructs a 2D point defined by a and \spad{b} of type Integer
osipnt`3`x`(Integer,Integer,Integer)->S`xSPointCategory&(S)``
osipnt`3`x`(Integer,Integer,Integer)->_$`cSPointCategory``\spad{sipnt(a,{} b,{} c)} constructs a 3D point defined by a,{} \spad{b} and \spad{c} of type Integer
osivec`2`x`(Integer,Integer)->S`xSPointCategory&(S)``
osivec`2`x`(Integer,Integer)->_$`cSPointCategory``\spad{sivec(a,{} b)} constructs a 2D vector defined by a and \spad{b} of type Integer
osivec`3`x`(Integer,Integer,Integer)->S`xSPointCategory&(S)``
osivec`3`x`(Integer,Integer,Integer)->_$`cSPointCategory``\spad{sivec(a,{} b,{} c)} constructs a 3D vector defined by a,{} \spad{b} and \spad{c} of type Integer
osmesh`2`x`(List(List(PT)),Boolean)->_$`dSceneIFS(PT)``\spad{smesh(ptin,{} clos)} constructs a ifs representation of a mesh from a 2 dimensional array of points
ospanningForestArrow`1`x`(A)->List(Tree(Integer))`xFiniteGraph&(A,S)``
ospanningForestArrow`1`x`(_$)->List(Tree(Integer))`cFiniteGraph(S)``\spad{spanningForestArrow(s)} constructs a spanning tree for every arrow.
ospanningForestNode`1`x`(A)->List(Tree(Integer))`xFiniteGraph&(A,S)``
ospanningForestNode`1`x`(_$)->List(Tree(Integer))`cFiniteGraph(S)``\spad{spanningForestNode(s)} constructs a spanning tree for every vertex.
ospanningTreeArrow`2`x`(A,NonNegativeInteger)->Tree(Integer)`xFiniteGraph&(A,S)``
ospanningTreeArrow`2`x`(_$,NonNegativeInteger)->Tree(Integer)`cFiniteGraph(S)``\spad{spanningTreeArrow(s,{} i)} constructs a spanning tree for graph \spad{'s'} rooted at the arrow indexed by 'i'. The tree will expand out from 'i' only stopping when reaching a arrow that has already been visited (that is: loop detected). Elements in the tree are Integer,{} a positive Integer represents a arrow and a negative Integer represents a repeated arrow. note: it is possible that nodes may be visited many ------times,{} only arrows must not be re-visited.
ospanningTreeNode`2`x`(A,NonNegativeInteger)->Tree(Integer)`xFiniteGraph&(A,S)``
ospanningTreeNode`2`x`(_$,NonNegativeInteger)->Tree(Integer)`cFiniteGraph(S)``\spad{spanningTreeNode(s,{} i)} constructs a spanning tree for graph \spad{'s'} rooted at the node indexed by 'i'. The tree will expand out from 'i' only stopping when reaching a vertex that has already been visited (that is: loop detected). Elements in the tree are Integer,{} a positive Integer represents a vertex and a negative Integer represents a repeated vertex.
ospnt`2`x`(DoubleFloat,DoubleFloat)->_$`cSPointCategory``\spad{spnt(a,{} b)} constructs a 2D point defined by a and \spad{b} of type \spad{R}
ospnt`3`x`(DoubleFloat,DoubleFloat,DoubleFloat)->_$`cSPointCategory``\spad{spnt(a,{} b,{} c)} constructs a 3D point defined by a,{} \spad{b} and \spad{c} of type \spad{R}
ostransform`1`x`((Complex(DoubleFloat))->Complex(DoubleFloat))->_$`dSTransform(PT)``\spad{stransform(cpx)} construct transform as function of complex variable can only be used when \spad{PT} is SArgand so this can be converted to \spad{PT} \spad{->} \spad{PT}
ostransform`1`x`((PT)->PT)->_$`dSTransform(PT)``\spad{stransform(gen)} construct transform in general form as a mapping from \spad{PT} to \spad{PT}
ostransform`1`x`(List(DoubleFloat))->_$`dSTransform(PT)``\spad{stransform(m)} construct transform using a multivector
ostransform`1`x`(List(List(DoubleFloat)))->_$`dSTransform(PT)``\spad{stransform(m)} constructs transform with given matrix elements
ostranslate`6`x`(DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat)->_$`dSTransform(PT)``\spad{stranslate(offsetx,{} offsety,{} offsetz,{} scalex,{} scaley,{} scalez)} constructs a transform which represents pure translation we can also combine with scale which,{} for instance,{} is useful when writing to \spad{SVG} file because the \spad{y} dimension is inverted
ostube`3`x`(List(Record(source:(DoubleFloat)->PT,ranges:List(Segment(DoubleFloat)),knots:List(DoubleFloat),points:List(PT))),DoubleFloat,Integer)->_$`dSceneIFS(PT)``\spad{stube(functions: List Clipd,{} r,{} n)} creates a tube of radius \spad{r} around the curve functions.
osubdiagramSvgLine`4`x`(Scene(SCartesian(2)),_$,Boolean,Boolean)->Void`dUndirectedGraph(S)``subdiagramSvg(\spad{sc},{} \spad{n},{} dispArrowName,{} deep) creates a branch of an \spad{SVG} diagram under an already existing scene node \spad{sc}. \spad{n:} \% is the graph that will be written dispArrowName: Boolean is \spad{true} to include the name of each arrow
osubdiagramSvg`4`x`(Scene(SCartesian(2)),A,Boolean,Boolean)->Void`xFiniteGraph&(A,S)``
osubdiagramSvg`4`x`(Scene(SCartesian(2)),_$,Boolean,Boolean)->Void`cFiniteGraph(S)``\spad{subdiagramSvg(sc,{} n,{} dispArrowName,{} deep)} creates a branch of an \spad{SVG} diagram diagram under an already existing scene node \spad{sc}. \spad{n:} \% is the graph that will be written dispArrowName: Boolean is \spad{true} to include the name of each arrow
osubdivide`1`x`(_$)->_$`dSceneIFS(PT)``\spad{subdivide(me)} for each face calculate a new point in the centre of the face,{} then build a new set of faces which include the new point.
osunion`2`x`(_$,_$)->_$`dSBoundary(PT)``\spad{sunion(x,{} y)} gives the union of two boundaries as a box,{} \indented{2}{that is it gives a box that is external to both.} \spad{x:} \% is first boundary to be combined \spad{y:} \% is second boundary to be combined
osvec`2`x`(DoubleFloat,DoubleFloat)->_$`cSPointCategory``\spad{svec(a,{} b)} constructs a 2D vector defined by a and \spad{b} of type \spad{R}
osvec`3`x`(DoubleFloat,DoubleFloat,DoubleFloat)->_$`cSPointCategory``\spad{svec(a,{} b,{} c)} constructs a 3D vector defined by a,{} \spad{b} and \spad{c} of type \spad{R}
oterminal`1`x`(S)->_$`cFiniteGraph(S)``\spad{terminal(a)} constructs a graph over a with a single vertex and a single loop
otoCayleyGraph`1`x`(PermutationGroup(S))->MultifunctionGraph(String)`dMultifunctionGraph(S)``convert PermutationGroup to a Cayley graph
otoCayleyGraph`2`x`(List(Permutation(S)),Boolean)->MultifunctionGraph(String)`dMultifunctionGraph(S)``convert permutation generators to a Cayley graph permList should contain generator permutations and should not contain identity permutation. if permutationNames then names generated represent permutation
otoObj`6`x`(_$,Reference(List(PT)),Reference(List(List(NonNegativeInteger))),Reference(NonNegativeInteger),STransform(PT),Record(mins:PT,maxs:PT))->Void`dScene(PT)``deprecated: this has been superseded by version with SBoundary(\spad{PT}) do not use,{} may be removed in the future.
otoObj`6`x`(_$,Reference(List(PT)),Reference(List(List(NonNegativeInteger))),Reference(NonNegativeInteger),STransform(PT),SBoundary(PT))->Void`dScene(PT)``\spad{toObj(n,{} ptLst,{} indexLst,{} indexNxt,{} tran,{} bb)} creates an .OBJ (Wavefront) file from scenegraph tree structure called recursively for each node,{} so when called on root node in scenegraph all other nodes in the scenegraph will get called. \spad{n} is the scene to be output to \spad{ptLst} and \spad{indexLst} \spad{ptLst} is th------------------------e points. This will be set to ref([]) at the start \indented{6}{and will be built up as this function is called recursively} \spad{indexLst} is list of faces,{} where faces are list of points indexed \indented{9}{by \spad{ptLst} This will be set to ref(nil()) at the start} \indented{6}{and will be built up as this function is called recursively} \spad{tran} is the default transform which may be overridden by subnodes \spad{bb} is the default boundary which may be overridd--en-- b--y --su--bn--od--es
otoPermutation`1`x`(_$)->PermutationGroup(NonNegativeInteger)`dMultifunctionGraph(S)``generates a permutation group from this graph assumes this graph represents a valid group
otoPoint`1`x`(_$)->_$`cSPointCategory``\spad{toPoint(p)} returns a Point with the same coordinates as \spad{p} If \spad{p} was originally a vector then that will be treated as the distance from the origin.
otoSVG`8`x`(_$,Record(lineWidth:DoubleFloat,lineCol:String,fillCol:String,matOpacity:DoubleFloat),STransform(PT),Record(mins:PT,maxs:PT),DoubleFloat,Boolean,Boolean,SceneNamedPoints(PT))->XmlElement`dScene(PT)``deprecated: this has been superseded by version with SBoundary(\spad{PT}) do not use,{} may be removed in the future.
otoSVG`8`x`(_$,Record(lineWidth:DoubleFloat,lineCol:String,fillCol:String,matOpacity:DoubleFloat),STransform(PT),SBoundary(PT),DoubleFloat,Boolean,Boolean,SceneNamedPoints(PT))->XmlElement`dScene(PT)``\spad{toSVG(n,{} mat,{} tran,{} bb,{} scale,{} clipEn,{} useInteger,{} npt)} creates an XmlElement containing a 'SVG' representation of node \spad{'n'} and the nodes below it. \spad{n} is the scene to be output to \spad{XML} elements \spad{mat} is the default material which may be overridden by sub------------------------nodes \spad{tran} is the default transform which may be overridden by subnodes \spad{bb} is the default boundary which may be overridden by subnodes \spad{scale} is the \spad{scale} used to \spad{scale} into canvas,{} it would be better \indented{6}{to merge this into trans.} \spad{clipEn} if \spad{true} this clips the output to the boundary \spad{useInteger} if \spad{true} truncate to integer values. \spad{npt} names points can be provided. If not required then set \inde--nt--ed--{4--}{--to-- n--am--ed--Br--an--ch--([],{} [])}
otoString`1`x`(_$)->String`dSceneNamedPoints(PT)``\spad{toString(n)} returns string representation for debug purposes.
otoVector`1`x`(_$)->_$`cSPointCategory``\spad{toVector returns} a Vector with the same coordinates as \spad{p} If \spad{p} was originally a point then the vector will be the distance from the origin.
otoX3D`4`x`(_$,Record(lineWidth:DoubleFloat,lineCol:String,fillCol:String,matOpacity:DoubleFloat),STransform(PT),Record(mins:PT,maxs:PT))->XmlElement`dScene(PT)``deprecated: this has been superseded by version with SBoundary(\spad{PT}) do not use,{} may be removed in the future.
otoX3D`4`x`(_$,Record(lineWidth:DoubleFloat,lineCol:String,fillCol:String,matOpacity:DoubleFloat),STransform(PT),SBoundary(PT))->XmlElement`dScene(PT)``\spad{toX3D(n,{} mat,{} tran,{} bb)} creates an XmlElement containing a 'X3D' representation of node \spad{'n'} and the nodes below it. \spad{n} is the scene to be output to \spad{XML} elements \spad{mat} is the default material which may be overridden by subnodes \spad{tran} is the default transform which may be overridden by subnodes \spad{bb} ------------------------is the default boundary which may be overridden by subnodes
otransferGraph`3`x`(UndirectedGraph(Integer),Integer,Integer)->UndirectedGraph(Integer)`dVelocitiesToGraph(K)``\spad{transferGraph(vG,{} x,{} y)} transfer all internal coordinates of the edges of the graph \spad{vG} by \spad{x} and \spad{y}.
oundirectedGraph`1`x`(List(Record(value:S,posX:NonNegativeInteger,posY:NonNegativeInteger)))->_$`dUndirectedGraph(S)``constructor for graph with given objects more objects and arrows can be added later if required.
oundirectedGraph`1`x`(List(S))->_$`dUndirectedGraph(S)``constructor for graph with given list of object names. Use this version of the constructor if you don\spad{'t} intend to create diagrams and therefore don\spad{'t} care about \spad{x},{} \spad{y} coordinates. more objects and arrows can be added later if required.
oundirectedGraph`2`x`(List(Record(value:S,posX:NonNegativeInteger,posY:NonNegativeInteger)),List(Record(name:String,arrType:NonNegativeInteger,fromOb:NonNegativeInteger,toOb:NonNegativeInteger,xOffset:Integer,yOffset:Integer,map:List(NonNegativeInteger))))->_$`dUndirectedGraph(S)``constructor for graph with given objects and arrows more objects and arrows can be added later if required.
oundirectedGraph`2`x`(List(S),List(List(NonNegativeInteger)))->_$`dUndirectedGraph(S)``constructor for graph with given objects and adjacency matrix.
ounion`1`x`(List(_$))->_$`dSBoundary(PT)``\spad{union(x)} constructs a compound boundary from the union of \spad{x} \spad{x:} List \% is supplied list of boundaries to form union
ounitVector`1`x`(_$)->_$`cSPointCategory``\spad{unitVector(p)} returns a vector with the same direction as \spad{p} but with unit length. We scale until length is 1
ounit`2`x`(List(S),String)->_$`cFiniteGraph(S)``\spad{unit(objs,{} arrowName)} constructs a graph with vertices (from \spad{objs}) and arrows from each object to itself. arrowName is a prefix for all arrow names,{} this will be followed by a number starting at 1 and incremented for each arrow
ovelocityMatrixToGraph`3`x`(Matrix(Integer),Integer,Integer)->UndirectedGraph(Integer)`dVelocitiesToGraph(K)``velocityMatrixToGraph: (\spad{vM},{} \spad{x},{} \spad{y}) creates a graph with nodes being numbered velocities,{} (standard coordinates) being 2 dim velocity vectors.
oweightedDistanceMatrix`1`x`(_$)->TwoDimensionalArray(Union(W,"disjoint"))`dWeightedGraph(S,W)``The elements of the returned array will represent the distance weights between vertices. if there is no connection between the vertices then the element will be set to "disjoint"
oweightedGraph`1`x`(List(Record(value:S,posX:NonNegativeInteger,posY:NonNegativeInteger,weight:W)))->_$`dWeightedGraph(S,W)``constructor for graph with given objects more objects and arrows can be added later if required.
oweightedGraph`1`x`(List(S))->_$`dWeightedGraph(S,W)``constructor for graph with given list of object names. Use this version of the constructor if you don\spad{'t} intend to create diagrams and therefore don\spad{'t} care about \spad{x},{} \spad{y} coordinates. more objects and arrows can be added later if required.
oweightedGraph`2`x`(List(Record(value:S,posX:NonNegativeInteger,posY:NonNegativeInteger)),List(Record(name:String,arrType:NonNegativeInteger,fromOb:NonNegativeInteger,toOb:NonNegativeInteger,xOffset:Integer,yOffset:Integer,map:List(NonNegativeInteger))))->_$`dWeightedGraph(S,W)``constructor for graph with given objects and arrows more objects and arrows can be added later if required.
oweightedGraph`2`x`(List(Record(value:S,posX:NonNegativeInteger,posY:NonNegativeInteger,weight:W)),List(Record(name:String,weight:W,fromOb:NonNegativeInteger,toOb:NonNegativeInteger,xOffset:Integer,yOffset:Integer,map:List(NonNegativeInteger))))->_$`dWeightedGraph(S,W)``\spad{weightedGraph(ob,{} ar)} constructs graph with objects on and arrows ar. More objects and arrows can be added later if required.
oweightedGraph`2`x`(List(S),List(List(NonNegativeInteger)))->_$`dWeightedGraph(S,W)``constructor for graph with given objects and adjacency matrix.
owriteObj`2`x`(_$,String)->Void`dScene(PT)``\spad{writeObj(n,{} filename)} writes an 'OBJ' (Wavefront) representation of node \spad{'n'} to the filename supplied.
owriteSvgQuantised`2`x`(_$,String)->Void`dScene(PT)``\spad{writeSvgQuantised(n,{} filename)} writes an 'SVG' representation of node \spad{'n'} to the filename supplied.
owriteSvg`2`x`(_$,String)->Void`dScene(PT)``\spad{writeSvg(n,{} filename)} writes an 'SVG' representation of node \spad{'n'} to the filename supplied.
owriteVRML`2`x`(XmlElement,String)->Void`pExportXml``\spad{writeVRML(content,{} filename)} writes the element as \spad{VRML2}. \spad{VRML2} is not \spad{xml} but it has the same semantics and node names as \spad{X3D} but a different syntax so it makes sense to create an \spad{XML} structure and then format the output differently.
owriteVRML`2`x`(_$,String)->Void`dScene(PT)``\spad{writeVRML(n,{} filename)} writes an 'VRML' representation of node \spad{'n'} to the filename supplied.
owriteX3d`2`x`(_$,String)->Void`dScene(PT)``writeX3d: (\spad{n},{} filename) writes an 'X3D' representation of node \spad{'n'} to the filename supplied.
owriteXml`2`x`(XmlElement,String)->Void`pExportXml``\spad{writeXml(content,{} filename)} writes an \spad{xml} element and all the elements below it to an \spad{xml} file. This assumes that all elements,{} in a file,{} have a single root which is usually the case.
oxform`2`x`(_$,PT)->PT`dSTransform(PT)``\spad{xform(tr,{} inpt)} apply transform to a point producing another point
oxmlAttribute`2`x`(String,List(String))->_$`dXmlAttribute``xmlAttribute: (name: String,{} values: List String) constructs a xmlAttribute from its name and list of values
oxmlAttribute`2`x`(String,String)->_$`dXmlAttribute``\spad{xmlAttribute(name,{} value)} construct a xmlAttribute from its \spad{name} and value
oxmlElement`3`x`(String,List(_$),List(XmlAttribute))->_$`dXmlElement``\spad{xmlElement(name,{} elements,{} attributes)} construct an element with structured \spad{elements}
oxmlElement`3`x`(String,String,List(XmlAttribute))->_$`dXmlElement``\spad{xmlElement(name,{} txt,{} attributes)} construct an element with unstructured text
o~=`2`x`(A,A)->Boolean`xFiniteGraph&(A,S)``
o~`1`x`(_$)->_$`dDirectedGraph(S)``The complement or inverse of a graph is a graph on the same vertices such that there is an arrow if and only if there is not an arrow in its compliment. That is,{} it is the compliment of the arrows but is not the set complement. for more information see: http: //en.wikipedia.org/wiki/Complement_graph
o~`1`x`(_$)->_$`dMultifunctionGraph(S)``The complement or inverse of a graph is a graph on the same vertices such that there is an arrow if and only if there is not an arrow in its compliment. That is,{} it is the compliment of the arrows but is not the set complement. for more information see: http: //en.wikipedia.org/wiki/Complement_graph
pExportXml`0`x`()->etc``XML`PointCategory is the category of points and vectors in space. Points may be used to represent shapes in a scenegraph such as: the vertices of a cube or points along a line. Shapes such as these may be defined explicitly or may be plotted. We implement SetCategory to allow us to curry transforms from one point to another.
xFiniteGraph&`2`x`(FiniteGraph(S),S:SetCategory)->etc`(A,S)`FGRPH-`This is used with graph theory code (FiniteGraph,{} DirectedGraph. FunctionGraph,{} and so on) to represent a loop as either a sequence of vertex or arrow indexes depending on context. The main benefit is that the loop is stored in a canonical way so that loops can be quickly compared using \spad{'='}.
xInternalMessageLevel&`1`x`(InternalMessageLevel)->etc`(S)`IML-`For each domain which uses this category we define three internal message level pointers \spad{pF1},{} \spad{pF2},{} \spad{pF3},{} to boolean values,{} default pointers are set to \spad{false}. This gives three message levels 1,{}2,{}3,{} default is 0. The value of the pointers are used as print flags. If a code has statements like "if deref \spad{pF1} then print ...." the users of the domain can dynamically change the message level-------- to get interval informations. This can be done by \axiom{setMessageLevel}
xSPointCategory&`1`x`(SPointCategory)->etc`(S)`SPTCAT-`PointCategory is the category of points and vectors in space. Points may be used to represent shapes in a scenegraph such as: the vertices of a cube or points along a line. Shapes such as these may be defined explicitly or may be plotted. We implement SetCategory to allow us to curry transforms from one point to another.
