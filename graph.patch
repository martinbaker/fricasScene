From 06736b296eaac27050e048904d0d9b3beb2b1f4d Mon Sep 17 00:00:00 2001
From: Martin Baker <ax87438@martinb.com>
Date: Tue, 13 Sep 2016 17:43:27 +0100
Subject: [PATCH 2/2] update graph code

---
 src/algebra/graph.spad | 222 ++++++++++++++++++++++++++++++++++++++++---------
 1 file changed, 184 insertions(+), 38 deletions(-)

diff --git a/src/algebra/graph.spad b/src/algebra/graph.spad
index c1638ff..feca4b3 100644
--- a/src/algebra/graph.spad
+++ b/src/algebra/graph.spad
@@ -1149,6 +1149,8 @@ FiniteGraph(S) : Category == Definition where
    addObject! : (s : %, n : OBJT) -> %
     ++ addObject!(s, n) adds object with coordinates n to the
     ++ graph s.
+   addArrow! : (s : %, ar: ARROW) -> %
+    ++ addArrow!(s, ar) adds an arrow ar to the graph s
    addArrow! : (s : %, name : String, n1 : NNI, n2 : NNI) -> %
     ++ addArrow!(s, nm, n1, n2) adds an arrow to the graph s, where:
     ++ nm is the name of the arrow
@@ -1168,8 +1170,9 @@ FiniteGraph(S) : Category == Definition where
    getVertices : (s : %) -> List OBJT
     ++ getVertices(s) returns a list of all the vertices (or objects)
     ++ of the graph s.
-   getVertexIndex :  (%, S) -> NNI
+   getVertexIndex : (s : %, o : S) -> NNI
     ++ getVertexIndex(s, o) gives index of object o.
+    ++ returns 0 if not found
    getArrows : (s : %) -> List ARROW
     ++ getArrows(s) returns a list of all the arrows (or edges)
    flatten : (n : DirectedGraph(%)) -> %
@@ -1390,6 +1393,11 @@ FiniteGraph(S) : Category == Definition where
     ++ fileName: String is the name of the SVG file that will be created
     ++ n: % is the graph that will be written
     ++ dispArrowName: Boolean is true to include the name of each arrow
+   diagramsSvg : (fileName : String, ln : List %, dispArrowName : Boolean) -> Void
+    ++ creates SVG diagram containing multiple graphs
+    ++ fileName: String is the name of the SVG file that will be created
+    ++ ln: List % is list of graphs that will be written
+    ++ dispArrowName: Boolean is true to include the name of each arrow
    deepDiagramSvg : (fileName : String, n : %, dispArrowName : Boolean) -> Void
    diagramWidth : (s : %) -> NNI
     ++ diagramWidth(s) returns the width of the diagram that will be
@@ -1439,9 +1447,13 @@ FiniteGraph(S) : Category == Definition where
 
    math_to_string ==> mathObject2String$Lisp
 
+   -- getVertexIndex(s, o) gives index of object o.
+   -- returns 0 if not found
    getVertexIndex(s : %, o : S) : NNI ==
-       for i in 1.. for v in getVertices(s) repeat
+       lv := getVertices(s)
+       for i in 1.. for v in lv repeat
            if v.value = o then return i
+       0::NNI
 
    addArrow!(s : %, aname : String, o1 : S, o2 : S) : % ==
        addArrow!(s, aname, getVertexIndex(s, o1), getVertexIndex(s, o2))
@@ -2064,6 +2076,19 @@ FiniteGraph(S) : Category == Definition where
     subdiagramSvg(sc, n, dispArrowName, false)
     writeSvg(sc, fileName)
 
+   -- creates SVG diagram containing multiple graphs
+   -- fileName: String is the name of the SVG file that will be created
+   -- ln: List % is list of graphs that will be written
+   -- dispArrowName: Boolean is true to include the name of each arrow
+   diagramsSvg(fileName : String, ln : List %, dispArrowName : Boolean) : Void ==
+    dW : NNI := 0
+    for n in ln repeat dW := (dW + diagramWidth(n) + 10)::NNI
+    view := boxBoundary(sipnt(0, 0)$PT, sipnt(dW, _
+                           diagramHeight(first ln)+10::NNI)$PT )$SBoundary(PT)
+    sc := createSceneRoot(view)$Scene(PT)
+    for n in ln repeat subdiagramSvg(sc, n, dispArrowName, false)
+    writeSvg(sc, fileName)
+
    deepDiagramSvg(fileName : String, n : %, dispArrowName : Boolean) : Void ==
     view := boxBoundary(sipnt(0, 0)$PT, sipnt(diagramWidth(n)+10::NNI, _
                            diagramHeight(n)+10::NNI)$PT)$SBoundary(PT)
@@ -2490,22 +2515,19 @@ DirectedGraph(S) : Exports == Implementation where
       else s.objects := concat(obs, n)
     s
 
+  -- adds an arrow to this graph, its endpoints are specified by ar.
+  addArrow!(s : %, ar: ARROW) : % ==
+    s.arrows := concat(s.arrows, ar)
+    s
+
   -- adds an arrow to this graph, where:
   -- s is the graph where the arrow is to be added
   -- nm is the name of the arrow
   -- n1 is the index of the start object
   -- n2 is the index of the end object
   addArrow!(s : %, nm : String, n1 : NNI, n2 : NNI) : % ==
-    arrss : List ARROW := s.arrows
     a : ARROW := [nm, 0::NNI, n1, n2, 0::Integer, 0::Integer, []]
-    if arrss = nil()
-      then
-        s.arrows := [a]
-        return s
-      else
-        arrs : List ARROW := concat(arrss, a)
-        s.arrows := arrs
-        return s
+    addArrow!(s, a)
 
   -- adds an arrow to this graph, where:
   -- s is the graph where the arrow is to be added
@@ -2514,16 +2536,8 @@ DirectedGraph(S) : Exports == Implementation where
   -- n2 is the index of the end object
   -- mp is a map represented by this arrow
   addArrow!(s : %, nm : String, n1 : NNI, n2 : NNI, mp : List NNI) : % ==
-    arrss : List ARROW := s.arrows
     a : ARROW := [nm, 0::NNI, n1, n2, 0::Integer, 0::Integer, mp]
-    if arrss = nil()
-      then
-        s.arrows := [a]
-        return s
-      else
-        arrs : List ARROW := concat(arrss, a)
-        s.arrows := arrs
-        return s
+    addArrow!(s, a)
 
   -- returns a list of all the vertices (or objects)
   getVertices(s : %) : List OBJT ==
@@ -3144,6 +3158,11 @@ FunctionGraph(S) : Exports == Implementation where
     error "this form of addObject! not supported in functionGraph"
     [[]]
 
+  -- Don't use. Put here only to implement FiniteGraph
+  addArrow!(s : %, ar: ARROW) : % ==
+    error "addArrow! not implemented in functionGraph"
+    s
+
   -- This should really be replaceArrow! in functionGraph but
   -- we use the name addArrow! for compatibility with directedGraph
   -- and any other implementations of FiniteGraph
@@ -3453,6 +3472,7 @@ UndirectedGraph(S) : Exports == Implementation where
  DF ==> DoubleFloat
  PT ==> SCartesian(2)
  x<<y ==> hconcat(x::OutputForm,y::OutputForm)
+ math_to_string ==> mathObject2String$Lisp
 
  Exports ==> FiniteGraph(S) with
 
@@ -3496,6 +3516,12 @@ UndirectedGraph(S) : Exports == Implementation where
     ++ as tensor product but returns %.
   closedCartesian : (a : %, b : %, f : (S, S)->S) -> %
     ++ as Cartesian product but returns %.
+  diagramSvg2 : (fileName : String, n : %, dispArrowName : Boolean) -> Void
+    ++ diagramSvg(fileName, n, dispArrowName) creates an SVG diagram. This
+    ++ is an altenative version which does not shorten lines.
+    ++ fileName: String is the name of the SVG file that will be created
+    ++ n: % is the graph that will be written
+    ++ dispArrowName: Boolean is true to include the name of each arrow
   coerce : (poset :FinitePoset(S)) -> %
     ++ coerce FinitePoset to graph
 
@@ -3618,22 +3644,19 @@ UndirectedGraph(S) : Exports == Implementation where
       else s.objects := concat(obs, n)
     s
 
+  -- adds an arrow to this graph, its endpoints are specified by ar.
+  addArrow!(s : %, ar: ARROW) : % ==
+    s.arrows := concat(s.arrows, ar)
+    s
+
   -- adds an arrow to this graph, where:
   -- s is the graph where the arrow is to be added
   -- nm is the name of the arrow
   -- n1 is the index of the start object
   -- n2 is the index of the end object
   addArrow!(s : %, nm : String, n1 : NNI, n2 : NNI) : % ==
-    arrss : List ARROW := s.arrows
     a : ARROW := [nm, 0::NNI, n1, n2, 0::Integer, 0::Integer, []]
-    if arrss = nil()
-      then
-        s.arrows := [a]
-        return s
-      else
-        arrs : List ARROW := concat(arrss, a)
-        s.arrows := arrs
-        return s
+    addArrow!(s, a)
 
   -- adds an arrow to this graph, where:
   -- s is the graph where the arrow is to be added
@@ -3642,16 +3665,8 @@ UndirectedGraph(S) : Exports == Implementation where
   -- n2 is the index of the end object
   -- mp is a map represented by this arrow
   addArrow!(s : %, nm : String, n1 : NNI, n2 : NNI, mp : List NNI) : % ==
-    arrss : List ARROW := s.arrows
     a : ARROW := [nm, 0::NNI, n1, n2, 0::Integer, 0::Integer, mp]
-    if arrss = nil()
-      then
-        s.arrows := [a]
-        return s
-      else
-        arrs : List ARROW := concat(arrss, a)
-        s.arrows := arrs
-        return s
+    addArrow!(s, a)
 
   -- returns a list of all the vertices (or objects)
   getVertices(s : %) : List OBJT ==
@@ -3979,6 +3994,128 @@ UndirectedGraph(S) : Exports == Implementation where
   coerce(poset : FinitePoset(S)) : % ==
       undirectedGraph(poset)
 
+  --- JG: start new code: 
+  -- output graph to OutputForm
+  -- Overrides coerce in FiniteGraph
+  coerce(n : %) : OutputForm ==
+    vertices : OutputForm := "Vertices: " :: OutputForm
+    lv : List OBJT := getVertices(n)
+    lvof : List OutputForm := [(v.value)::OutputForm for v in lv]
+    vertices := hconcat(vertices, commaSeparate lvof)
+    -- now represent arrows
+    arrows : OutputForm := "Edges: " :: OutputForm
+    la : List ARROW := getArrows(n)
+    if la = nil() then return vertices
+    laof : List OutputForm := [hconcat [(ar.fromOb):: OutputForm,_
+           "-" :: OutputForm, (ar.toOb):: OutputForm]  for ar in la]
+    arrows := hconcat(arrows, commaSeparate laof)
+    pile [vertices, arrows]
+
+  -- subdiagramSvg(sc, n, dispArrowName, deep) creates a branch of an
+  -- SVG diagram diagram under an already existing scene node sc
+  -- n: % is the graph that will be written
+  -- dispArrowName: Boolean is true to include the name of each arrow
+  -- replaces subdiagramSvg in FiniteGraph to give a line without
+  -- arrows for undirected graphs.
+  subdiagramSvg(sc : Scene(PT), n : %, dispArrowName : Boolean, deep : Boolean) : Void ==
+    --print "subdiagramSvgLine called from UndirectedGraph"::OutputForm
+    -- all arrows in undirected graphs will be black
+    mt := addSceneMaterial(sc,3::DF,"black","black")$Scene(PT)
+    ls : List OBJT := getVertices(n)
+    -- indexPointx and indexPointy holds an array of the x and y coordinates
+    -- so they can be looked up using an index value.
+    indexPointx : List NNI := []
+    indexPointy : List NNI := []
+    -- indexBounds holds an array of scene nodes so they can
+    -- be looked up using an index value (to draw arrows upto
+    -- their boundary).
+    indexBounds : List Scene(PT) := []
+    -- indexNodes holds an array of vertices so they can
+    -- be looked up using an index value (in case we need to look
+    -- inside them for second order graphs).
+    indexNodes : List S := []
+    for i in ls repeat
+      indexNodes := concat(indexNodes, i.value)
+      s : String := math_to_string i.value
+      x : NNI := i.posX
+      y : NNI := i.posY
+      indexPointx := concat(indexPointx, x)
+      indexPointy := concat(indexPointy, y)
+      -- if this is a second order graph then draw sub graphs
+      -- otherwise draw vertex name
+      tn := addSceneText(sc, s, 32::NNI, sipnt(x, y)$PT)$Scene(PT)
+      indexBounds := concat(indexBounds, tn)
+    arrs : List ARROW := getArrows(n)
+    -- if no arrows then just write vertex names
+    if arrs = nil() then return void
+    -- if this is a second order graph then we need to get the inner objects
+    IOBJT ==> Record(value : DirectedGraph(String), posX : NNI, posY : NNI)
+    innerOb : List List IOBJT := []
+    -- now draw lines without arrows in diagram
+    for arrow in arrs for arrn in 1..#arrs repeat
+      fromX : NNI := indexPointx.(arrow.fromOb)
+      toX : NNI := indexPointx.(arrow.toOb)
+      fromY : NNI := indexPointy.(arrow.fromOb)
+      toY : NNI := indexPointy.(arrow.toOb)
+
+      -- diagram can look better if edges are drawn slightly offset but
+      -- this needs to be fine tuned to look correct.
+      fromX := (fromX+arrow.xOffset)::NNI
+      toX := (toX+arrow.xOffset)::NNI
+      fromY := (fromY+arrow.yOffset)::NNI
+      toY := (toY+arrow.yOffset)::NNI
+
+      -- for arrow name we want to position text at the mid point of the
+      -- arrow, this is given by (start + end)/2. We divide integer by 2
+      -- by shifting binary number one place to the left.
+      midX : NNI := shift(toX + fromX, -1)
+      midY : NNI := shift(toY + fromY, -1)
+      -- get information to set line colour
+      arrIndex : List NNI := arrowsToNode(n, arrow.fromOb)
+      arrNumber : Integer := position(arrn, arrIndex)
+      rema : Integer := divide(arrNumber, 8).remainder
+      -- if this is a second order graph then we draw inner arrows
+      fnode : Scene(PT) := indexBounds.(arrow.fromOb)
+      tnode : Scene(PT) := indexBounds.(arrow.toOb)
+      offset : PT := sipnt(arrow.xOffset, arrow.yOffset)$PT
+      -- next we add the lines.
+      arrNode := addSceneLine(mt, fnode, tnode, (diagramWidth(n)+10)::DF,deep)
+      --print(vconcat([_
+      -- hconcat("fgraph subdiagramSvg sc="::OutputForm,sc::OutputForm)$OutputForm,_
+      -- hconcat(" n="::OutputForm,n::OutputForm)$OutputForm,_
+      -- hconcat(" arrNode="::OutputForm,arrNode::OutputForm)$OutputForm])$OutputForm)
+      -- add the name of the arrow
+      if dispArrowName then
+        s : String := arrow.name
+        addSceneText(mt, s, 32::NNI, sipnt(midX, midY)$PT)$Scene(PT)
+    return void
+
+   -- creates an SVG diagram
+   -- fileName: String is the name of the SVG file that will be created
+   -- n: % is the graph that will be written
+   -- dispArrowName: Boolean is true to include the name of each arrow
+  diagramSvg(fileName : String, n : %, dispArrowName : Boolean) : Void ==
+    --print "diagramSvgLine called from UndirectedGraph"::OutputForm
+    view := boxBoundary(sipnt(0, 0)$PT, sipnt(diagramWidth(n)+10::NNI, _
+                           diagramHeight(n)+10::NNI)$PT)$SBoundary(PT)
+    sc := createSceneRoot(view)$Scene(PT)
+    subdiagramSvg(sc, n, dispArrowName, true)
+    writeSvgQuantised(sc, fileName)
+
+   -- creates an SVG diagram. This is an altenative version which does
+   -- not shorten lines.
+   -- fileName: String is the name of the SVG file that will be created
+   -- n: % is the graph that will be written
+   -- dispArrowName: Boolean is true to include the name of each arrow
+  diagramSvg2(fileName : String, n : %, dispArrowName : Boolean) : Void ==
+    --print "diagramSvgLine called from UndirectedGraph"::OutputForm
+    view := boxBoundary(sipnt(0, 0)$PT, sipnt(diagramWidth(n)+10::NNI, _
+                           diagramHeight(n)+10::NNI)$PT)$SBoundary(PT)
+    sc := createSceneRoot(view)$Scene(PT)
+    subdiagramSvg(sc, n, dispArrowName, false)
+    writeSvgQuantised(sc, fileName)
+
+--- JG: end new code
 
 )if false
 
@@ -4235,6 +4372,11 @@ MultifunctionGraph(S) : Exports == Implementation where
     error "this form of addObject! not supported in multifunctionGraph"
     [[]]
 
+  -- Don't use. Put here only to implement FiniteGraph
+  addArrow!(s : %, ar: ARROW) : % ==
+    error "addArrow! not implemented in multifunctionGraph"
+    s
+
   -- Don't use.
   -- This should really be replaceFirst Arrow! in multifunctionGraph
   -- we put hare for compatibility with directedGraph only
@@ -4972,6 +5114,10 @@ WeightedGraph(S, W) : Exports == Implementation where
     error "this form of addObject! not supported in multifunctionGraph"
     [[], []]
 
+  -- Here only to implement FiniteGraph, not very useful as it has zero weight
+  addArrow!(s : %, ar: ARROW) : % ==
+    addWArrow!(s,ar.name, ar.fromOb, ar.toOb, 0$W)
+
   -- included only for compatibility with FiniteGraph
   -- adds an arrow with zero weight
   addArrow!(s : %, nm : String, n1 : NNI, n2 : NNI) : % ==
-- 
2.1.4

